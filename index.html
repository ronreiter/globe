<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Globe Visualization</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; cursor: grab; }
        canvas:active { cursor: grabbing; }
    </style>
</head>
<body>
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script>
        // Configuration parameters for performance/quality tradeoff
        const CONFIG = {
            // Globe appearance
            globeRadius: 11,                  // Size of the globe
            globeSegments: 64,                // Resolution of the globe (32-128, lower for better performance)
            atmosphereSize: 1.03,             // Size of atmosphere relative to globe (1.1-1.5)
            atmosphereOpacity: 0.1,           // Opacity of atmosphere (0.1-0.5)
            atmosphereGlow: 1.0,              // Intensity of atmosphere glow effect (1.0-3.0)
            
            // Arc color palette (in hex format with adjusted brightness and more saturation)
            arcColors: [
                0xD02C34, // Deeper Red
                0xE9A23A, // Golden Yellow
                0x5494D4, // Richer Blue
                0x8A5BC8, // Deeper Purple
                0xCF3250, // Deeper Pink
                0x9240B3, // Rich Violet
                0xE06C33, // Burnt Orange
                0x50A0D8  // Azure Blue
            ],
            
            // Land points
            numPoints: 25000,                 // Maximum points to generate (3000-25000, lower for better performance)
            dotSize: 0.06,                    // Size of land dots (0.05-0.1)
            dotSegments: 6,                   // Land dot geometry segments (4-8, lower for better performance)
            dotOpacity: 0.5,                  // Opacity of land dots (0.1-1.0)
            hoverEffect: 0.05,                // Strength of dot hover effect (0.1-0.5)
            hoverPull: 0.45,                  // The focus of the hover effect
            
            // Arcs
            maxConcurrentArcs: 10,            // Maximum concurrent arcs (6-40, lower for better performance)
            arcFrequency: 0.4,                // How often new arcs appear (higher = less frequent)
            arcTimingVariation: 0.15,         // Randomness in arc timing (0-1, higher = more random)
            arcTubeSegments: 18,              // Maximum tube segments for arcs (6-18, lower for better performance) 
            arcRadialSegments: 6,             // Radial segments for arc tubes (3-8, lower for better performance)
            arcThickness: 0.038,              // Thickness of arcs (0.03-0.1)
            arcPointsCount: 45,               // Number of points in arc path (20-50, lower for better performance)
            
            // Animation and behavior
            rotationSpeed: 0.002,             // Speed of auto-rotation (0.001-0.003)
            arcGrowDuration: 0.7,             // Base duration for arc growth in seconds (0.5-1.5)
            arcRetreatDuration: 2.0,          // Base duration for arc retreat in seconds (0.8-3.0)
            
            // Impact effects
            impactSize: 0.08,                 // Maximum impact size as fraction of globe radius (0.05-0.2)
            
            // Rendering
            useHighPerformanceMode: false,    // Set true for better performance but lower visual quality
            skipFrames: 0                     // Number of frames to skip when updating (0-2, higher for better performance)
        };        
        
        // Auto-detect performance capabilities and adjust settings if needed
        // This helps ensure smooth performance on all devices without manual toggling
        function autoDetectPerformance() {
            // Only run auto-detection if high performance mode isn't explicitly set
            if (CONFIG.useHighPerformanceMode === false) {
                // Check for mobile devices which typically have less GPU power
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                // Check if device has a lower resolution screen (proxy for lower-end device)
                const hasLowResScreen = window.screen.width * window.screen.height < 1920 * 1080;
                
                // Check for lower memory (another proxy for capability)
                const hasLowMemory = navigator.deviceMemory !== undefined && navigator.deviceMemory < 4;
                
                // Apply medium performance adjustments if device seems limited
                if (isMobile || hasLowResScreen || hasLowMemory) {
                    console.log("Auto-detected limited device capabilities, applying performance optimizations");
                    
                    // Reduce complexity but not as drastically as high performance mode
                    CONFIG.globeSegments = Math.max(32, CONFIG.globeSegments * 0.7);
                    CONFIG.numPoints = Math.max(15000, CONFIG.numPoints * 0.7);
                    CONFIG.dotOpacity = Math.max(0.6, CONFIG.dotOpacity * 0.85); // Reduce dot opacity for better performance
                    CONFIG.maxConcurrentArcs = Math.max(25, CONFIG.maxConcurrentArcs * 0.8);
                    CONFIG.arcPointsCount = Math.max(25, CONFIG.arcPointsCount * 0.8);
                    CONFIG.skipFrames = 1; // Skip every other frame
                    
                    // Apply pixel ratio limitation
                    if (window.devicePixelRatio > 2) {
                        renderer.setPixelRatio(1.5); // Cap pixel ratio for high-DPI screens
                    }
                }
            }
        }
        
        // Run auto-detection
        autoDetectPerformance();
        
        // Set up the scene, camera, and renderer
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0D2E4E); // Deep blue background as requested
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        // Create renderer with performance optimizations
        const renderer = new THREE.WebGLRenderer({ 
            antialias: CONFIG.useHighPerformanceMode, // Disable antialiasing in high performance mode
            powerPreference: "high-performance",
            precision: "mediump" // Use medium precision for shaders - major performance boost with minimal visual impact
        });
        
        // Optimize renderer for better performance
        renderer.sortObjects = false; // Disable object sorting since depth is relatively straightforward in this scene
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        // Set appropriate pixel ratio for performance without sacrificing quality too much
        const optimizedPixelRatio = CONFIG.useHighPerformanceMode ? 1 : 
                                   (window.devicePixelRatio > 2 ? 1.5 : window.devicePixelRatio);
        renderer.setPixelRatio(optimizedPixelRatio);
        
        // Additional optimizations
        renderer.shadowMap.enabled = false; // Disable shadow maps as we don't use them
        document.body.appendChild(renderer.domElement);
        
        // Create a single parent group for the entire globe and all its elements
        const globeGroup = new THREE.Group();
        scene.add(globeGroup);
        
        // Create a blue globe with enhanced material for better glow and performance
        const radius = CONFIG.globeRadius;  // Use configurable radius
        const globeGeometry = new THREE.SphereGeometry(
            radius, 
            CONFIG.globeSegments, 
            CONFIG.globeSegments
        ); 
        const globeMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x005280,      // Darker blue for the base color
            shininess: 15,        // Reduced shininess for a more muted appearance
            specular: 0x223344,   // Reduced specular for less bright highlights
            emissive: 0x002a56,   // Darker emissive glow
            transparent: true,    // Enable transparency
            opacity: 0.94         // Slightly more opaque for deeper appearance
        });
        const globe = new THREE.Mesh(globeGeometry, globeMaterial);
        globeGroup.add(globe);
        
        // Add a slightly larger inner glow sphere for enhanced glow effect
        const innerGlowGeometry = new THREE.SphereGeometry(
            radius * 1.01, 
            Math.max(16, Math.floor(CONFIG.globeSegments * 0.5)), // Lower resolution is fine for glow
            Math.max(16, Math.floor(CONFIG.globeSegments * 0.5))
        );
        const innerGlowMaterial = new THREE.MeshBasicMaterial({
            color: 0x003466,      // Darker blue for inner glow
            transparent: true,
            opacity: 0.13,        // Slightly less opacity
            side: THREE.BackSide  // Only show the inside
        });
        const innerGlow = new THREE.Mesh(innerGlowGeometry, innerGlowMaterial);
        globeGroup.add(innerGlow);
        
        // Add a single atmosphere with light-based glow effect
        const atmosphereSize = radius * CONFIG.atmosphereSize;
        const atmosphereGeometry = new THREE.SphereGeometry(
            atmosphereSize,
            CONFIG.globeSegments, // Use same resolution as globe for smooth appearance
            CONFIG.globeSegments
        );
        
        // Create a material that will react well to light
        const atmosphereMaterial = new THREE.MeshPhongMaterial({
            color: 0x4499ff, // Bright blue base color
            transparent: true,
            opacity: CONFIG.atmosphereOpacity,
            side: THREE.BackSide, // Render the inside for volumetric effect
            blending: THREE.AdditiveBlending,
            depthWrite: false, // Important for proper transparency
            shininess: 90, // High shininess to catch light
            emissive: 0x2266ff, // Blue emissive glow
            emissiveIntensity: 0.8 // Strong emissive effect
        });
        
        // Create the atmosphere mesh
        const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
        globeGroup.add(atmosphere);
        
        // Add a dedicated glow light at the center of the globe
        const atmosphereLight = new THREE.PointLight(0x4499ff, CONFIG.atmosphereGlow, atmosphereSize * 3);
        atmosphereLight.position.set(0, 0, 0); // Centered
        globeGroup.add(atmosphereLight);
        
        // Store references for animation
        globeGroup.userData.atmosphere = atmosphere;
        globeGroup.userData.atmosphereLight = atmosphereLight;
        
        // Enhanced lighting for better glow and highlights
        const ambientLight = new THREE.AmbientLight(0x333344, 0.5); // Subtle bluish ambient light
        scene.add(ambientLight);
        
        // Main directional light (sun-like) - reduced intensity
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
        directionalLight.position.set(8, 8, 8);
        scene.add(directionalLight);
        
        // Enhanced blue backlight for stronger glow effect - increased intensity
        const backLight = new THREE.PointLight(0x0066ff, 3.5, 65);
        backLight.position.set(-20, 8, -20);
        scene.add(backLight);
        
        // Second backlight with different color for more dramatic effect
        const secondBackLight = new THREE.PointLight(0x0022aa, 2.2, 60);
        secondBackLight.position.set(-18, -5, -15);
        scene.add(secondBackLight);
        
        // Third backlight with cyan tint for edge highlights
        const thirdBackLight = new THREE.PointLight(0x00aaff, 1.8, 55);
        thirdBackLight.position.set(-15, 12, -18);
        scene.add(thirdBackLight);
        
        // Blue rim light from below for additional glow - more intense
        const rimLight = new THREE.PointLight(0x0044ff, 1.8, 55);
        rimLight.position.set(-5, -15, -10);
        scene.add(rimLight);
        
        // Soft white fill light for general illumination - reduced intensity to emphasize glow
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.25);
        fillLight.position.set(0, 15, 15);
        scene.add(fillLight);
        
        // Position camera with a higher angle view
        camera.position.z = 25;
        camera.position.y = 10; // Add elevation for top-down angle
        camera.lookAt(0, 0, 0); // Ensure camera is looking at the center of the globe
        
        // Load land coordinates (simplified version)
        const landPoints = [];
        const landDots = new THREE.Group();
        globeGroup.add(landDots);
        
        // Create land dots based on actual land/sea distribution
        function createLandPoints() {
            console.time('landPoints');
            
            // Use instance rendering instead of individual meshes for massive performance improvement
            // This allows us to render thousands of dots with minimal performance impact
            
            // Resolution settings - use configurable options
            const dotSize = CONFIG.dotSize; // Use configurable dot size
            
            // Create a single geometry for all dots
            const dotGeometry = new THREE.CircleGeometry(dotSize, CONFIG.dotSegments);
            
            // Create a material for all dots with better visual quality/performance balance
            const dotMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xbbeeff, // Light blue tint that contrasts with darker globe
                side: THREE.DoubleSide, // Make sure circles are visible from both sides
                transparent: true,
                opacity: CONFIG.dotOpacity, // Use the configurable opacity
                depthTest: true, // Enable depth testing for proper occlusion
                depthWrite: true, // Ensure dots write to depth buffer
                blending: THREE.NormalBlending // Use normal blending for better performance
            });

            // High-resolution world map bitmap (simplified representation of Earth's land masses)
            // Each row represents a latitude band from 90°N to 90°S
            // Each character in a row represents a longitude band from 180°W to 180°E
            // 1 = land, 0 = water
            const worldMap = ["000000000000000000000000000000000000000000000000000000001111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000000000000111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000000000001111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000000000001111111110111111111111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000000000000111111000011111111111111111111110000000000000000000000000000000000000000000000000000011111111100000000000000000000000000000000000000000000000000", "000000000000000000000000000000001110000000000000000000000000000011111111111111111110000000000000000000000000000000000000000000000000111111111111100000000000000000000000000000000000000000000000000", "000000000000000000000000000000111111101110000000111111100000000011111111111111110000000000000000000000000000000000000000000011100111111111111111111100111100000011000000000000000000000000000000000", "000000000000001111100000000000111111111110011100111111111000000001111111111111110000000000000000000000000000000000000000000011111111111111111111111111111111110011111111110000000000000000000000000", "000000001111111111110000111110000111111110011100110111111000000001111111111111110000000000000000000001111111110000000000110011111111111111111111111111111111111111111111111111110011100000000000000", "000001111111111111111111111111111111111100111111110001111100001111111111111111100000000000000000000111111111111110001111111101111111111111111111111111111111111111111111111111111111111111000000000", "000111111111111111111111111111111111111111111111100001111100000111111111100000000000000000000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000", "001111111111111111111111111111111111111111111110000111111100000111111111000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000", "001111111111111111111111111111111111111111111000000111111000000111111000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111000", "111111111111111111111111111111111111111111110000010011110000000111111000000000000000000000000001111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000", "111111111111111111111111111111111111111110000000111100110000000011110000000000000000000000000011111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000", "111111111111111111111111111111111111111000000011111100110000000001100000000000000000000000000011111111011111111111111111111111111111111111111111111111111111111111111111111111111100011111100000000", "111110100000111111111111111111111111110000000011111111110000000000000000000000000000000000000011111111001111111111111111111111111111111111111111111111111111111111111111111111111100111101000000000", "011000000000011111111111111111111111111000000011111111110000000000000000000000000000000000000000011110111111111111111111111111111111111111111111111111111111111111111111111000000000111110000000000", "000000000000001111111111111111111111111111100011111111110000000000000000000000000000000000000000011110111111111111111111111111111111111111111111111111111111111111111111111000000000111111000000000", "000000000000011111111111111111111111111111111111111111111100000000000000000000000000000000000001111011111111111111111111111111111111111111111111111111111111111111111111111000000000011111000000000", "000000000000011111111111111111111111111111011111111111111100000000000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111100000001111000000000", "000000000000011111111111111111111111111111111111111111111100000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000111000000000", "000000000000011111111111111111111111111111111111111111111000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000011000000000", "000000000000001111111111111111111111111111111111111111000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000000000000", "000000000000011111111111111111111111111111111111111100000000000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000000000000", "000000000000011111111111111111111111111111111111111111000000000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000000000000", "000000000000111111111111111111111111111111111111111111000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000100000000000000", "000000000001111111111111111111111111111111111111111100000000000000000000000000000000011001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000110000000000000", "000000000001111111111111111111111111111111111110110000000000000000000000000000000000111111111110111111111111111111111111111111111111111111111111111111111111111111111111111111110000111000000000000", "000000000011111111111111111111111111111111111100000000000000000000000000000000000000111111111000011111111111111111111111111111111111111111111111111111111111111111111111111111000000111000000000000", "000000000111111111111111111111111111111111111000000000000000000000000000000000000000111111110000000111111111111111111111111111111111111111111111111111111111111111111111111111000000110000000000000", "000000000111111111111111111111111111111111100000000000000000000000000000000000000000111111100000000111111101111111111111111111111111111111111111111111111111111111111111011111000000110000000000000", "000000000111111111111111111111111111111111000000000000000000000000000000000000000000111111100000001110011101111111111111111111111111111111111111111111111111111111111110000111100010110000000000000", "000000000111111111111111111111111111111110000000000000000000000000000000000000000000111110011111111100011101111111111111111111111111111111111111111111111111111111111111110111110111111000000000000", "000000000111111111111111111111111111111110000000000000000000000000000000000000000000001111111111110000000000011011111111111111111111111111111111111111111111111111111111110011110111111000000000000", "000000000011111111111111111111111111111000000000000000000000000000000000000000000000011111111111100000000000000001111111111111111111111111111111111111111111111111111111110011100111110000000000000", "000000000001111111111111111111111111110000000000000000000000000000000000000000000001111111111111111000011000000001111111111111111111111111111111111111111111111111111111110000000000000000000000000", "000000000000111111111111111111111111100000000000000000000000000000000000000000000001111111111111111110011111110011111111111111111111111111111111111111111111111111111111111100000000000000000000000", "000000000001111111111111111111111111000000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000", "000000000000111111111111111111100111000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000", "000000000000111111111111110000000111000000000000000000000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000", "000000000000111111111111000000000111000000000000000000000000000000000000000000001111111111111111111111111111111110111111111101111111111111111111111111111111111111111111111100000000000000000000000", "000000000000011111111111000000000011000000000000000000000000000000000000000000011111111111111111111111111111111111111111111100011111111111111111111111111111111111111111111100000000000000000000000", "000000000000011011111111000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111011111111111111000001111111111111111111111111111111111111000000000000000000000000", "000000000000000011111111000000000000000000000000000000000000000000000000000000111111111111111111111111111111111111111111111111111110000011111111111111111111111111111111110000000000000000000000000", "000000000000000011111110000111000000000000000000000000000000000000000000000000111111111111111111111111111111111111101111111111111110000001111111111111111111111111111111000000000000000000000000000", "000000000000000001111111000111000000000000000000000000000000000000000000000000111111111111111111111111111111111111111111111111111110000000111111111111000111111111100110000000000000000000000000000", "000000000000000001111111101111000000000000000000000000000000000000000000000000111111111111111111111111111111111111110111111111111100000000001111111110000111111111101110000000000000000000000000000", "000000000000000001111111111111000000000000000000000000000000000000000000000000111111111111111111111111111111111111111011111111111000000000001111111100000011111111111100000000000000000000000000000", "000000000000000000011111111111100000000000000000000000000000000000000000000000111111111111111111111111111111111111111011111111110000000000001111111000000001111111111000000000000000000000000000000", "000000000000000000000111111111110000000000000000000000000000000000000000000001111111111111111111111111111111111111111101111111100000000000001111110000000001111111111000000000000000000000000000000", "000000000000000000000000011111110000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111110000000000000000111110000000000011111111100000000000000000000000000000", "000000000000000000000000000111110000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111000000000000000000111110000000000011111111100000000000000000000000000000", "000000000000000000000000000001110000001111000000000000000000000000000000000001111111111111111111111111111111111111111111000011000000000000000111110000000000011111111100000000000000000000000000000", "000000000000000000000000000001110000111111111100000000000000000000000000000000011111111111111111111111111111111111111111111111000000000000000011110000000000011111111100000000000000000000000000000", "000000000000000000000000000001111001111111111110000000000000000000000000000000011111111111111111111111111111111111111111111111000000000000000011110000000000011101111000000000000000000000000000000", "000000000000000000000000000000011101111111111111100000000000000000000000000000001111111111111111111111111111111111111111111110000000000000000001100000000000001100100000000000000000000000000000000", "000000000000000000000000000000000101111111111111110000000000000000000000000000000111111111111111111111111111111111111111111110000000000000000000000000000000000000000000001100000000000000000000000", "000000000000000000000000000000000001111111111111111110000000000000000000000000000111111111111111111111111111111111111111111100000000000000000000000000000000110000000000001110000000000000000000000", "000000000000000000000000000000000001111111111111111111000000000000000000000000000001111100000111111111111111111111111111111000000000000000000000000000000000111000000000111110000000000000000000000", "000000000000000000000000000000000011111111111111111111100000000000000000000000000000000000000000111111111111111111111111111000000000000000000000000000000000011100000001111110000000000000000000000", "000000000000000000000000000000000011111111111111111111100000000000000000000000000000000000000000111111111111111111111111110000000000000000000000000000000000011110000011111110000000000000000000000", "000000000000000000000000000000000111111111111111111111100000000000000000000000000000000000000000111111111111111111111111100000000000000000000000000000000000001111000111111110000000000000000000000", "000000000000000000000000000000001111111111111111111111111000000000000000000000000000000000000001111111111111111111111111000000000000000000000000000000000000000111100111111100000000011100000000000", "000000000000000000000000000000001111111111111111111111111111000000000000000000000000000000000001111111111111111111111111000000000000000000000000000000000000000111100011111100000000011101100000000", "000000000000000000000000000000000111111111111111111111111111111000000000000000000000000000000000111111111111111111111110000000000000000000000000000000000000000011110011111000000000001111111100000", "000000000000000000000000000000001111111111111111111111111111111110000000000000000000000000000000011111111111111111111100000000000000000000000000000000000000000011110000000000000000001111111111000", "000000000000000000000000000000001111111111111111111111111111111111000000000000000000000000000000011111111111111111111000000000000000000000000000000000000000000001110000000000000000000001111111100", "000000000000000000000000000000000111111111111111111111111111111111000000000000000000000000000000001111111111111111111100000000000000000000000000000000000000000000110000000000000000000000111111100", "000000000000000000000000000000000011111111111111111111111111111111000000000000000000000000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000111111110", "000000000000000000000000000000000011111111111111111111111111111110000000000000000000000000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000011101111", "000000000000000000000000000000000001111111111111111111111111111100000000000000000000000000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000111", "000000000000000000000000000000000001111111111111111111111111111100000000000000000000000000000000000111111111111111111100000000000000000000000000000000000000000000000000000000000000011110001100001", "000000000000000000000000000000000001111111111111111111111111111100000000000000000000000000000000001111111111111111111100000110000000000000000000000000000000000000000000000000000000111110001100000", "000000000000000000000000000000000000111111111111111111111111111000000000000000000000000000000000001111111111111111111100001110000000000000000000000000000000000000000000000000001111111100011100000", "000000000000000000000000000000000000011111111111111111111111111000000000000000000000000000000000011111111111111111111100111110000000000000000000000000000000000000000000000000011111111110011110000", "000000000000000000000000000000000000001111111111111111111111111000000000000000000000000000000000011111111111111111111000111110000000000000000000000000000000000000000000000000111111111111111110000", "000000000000000000000000000000000000000011111111111111111111111000000000000000000000000000000000011111111111111111110000111110000000000000000000000000000000000000000000000001111111111111111110000", "000000000000000000000000000000000000000001111111111111111111111000000000000000000000000000000000001111111111111111100000111100000000000000000000000000000000000000000000000011111111111111111111000", "000000000000000000000000000000000000000001111111111111111111110000000000000000000000000000000000001111111111111111100001111100000000000000000000000000000000000000000000011111111111111111111111000", "000000000000000000000000000000000000000001111111111111111111110000000000000000000000000000000000000111111111111111100001111000000000000000000000000000000000000000000001111111111111111111111111100", "000000000000000000000000000000000000000001111111111111111111110000000000000000000000000000000000000111111111111111100001111000000000000000000000000000000000000000000001111111111111111111111111110", "000000000000000000000000000000000000000001111111111111111110000000000000000000000000000000000000000111111111111111100001111000000000000000000000000000000000000000000001111111111111111111111111110", "000000000000000000000000000000000000000001111111111111111000000000000000000000000000000000000000000111111111111111000001111000000000000000000000000000000000000000000001111111111111111111111111110", "000000000000000000000000000000000000000001111111111111111100000000000000000000000000000000000000000011111111111110000000000000000000000000000000000000000000000000000001111111111111111111111111110", "000000000000000000000000000000000000000001111111111111111000000000000000000000000000000000000000000011111111111100000000000000000000000000000000000000000000000000000011111111111111111111111111110", "000000000000000000000000000000000000000001111111111111111000000000000000000000000000000000000000000011111111111100000000000000000000000000000000000000000000000000000011111111111111111111111111110", "000000000000000000000000000000000000000001111111111111110000000000000000000000000000000000000000000001111111111000000000000000000000000000000000000000000000000000000001111111111111111111111111110", "000000000000000000000000000000000000000001111111111111110000000000000000000000000000000000000000000001111111110000000000000000000000000000000000000000000000000000000001111111111111111111111111100", "000000000000000000000000000000000000000000111111111111100000000000000000000000000000000000000000000000111111100000000000000000000000000000000000000000000000000000000011111111100011111111111111000", "000000000000000000000000000000000000000000111111111111100000000000000000000000000000000000000000000000111110000000000000000000000000000000000000000000000000000000000011111100000001111111111110000", "000000000000000000000000000000000000000000111111111110000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000011000000000000011111111100000", "000000000000000000000000000000000000000000111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111000000", "000000000000000000000000000000000000000000111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111110000000", "000000000000000000000000000000000000000000111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001111000000000", "000000000000000000000000000000000000000000111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000011111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000011111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000001111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000011111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000011111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000001111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000001111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000000111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000000011110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"];
            
            // Helper function to check if a point is on land
            function isLand(lat, lon) {
                // Convert to map indices - the worldMap has lat from 90°N to 90°S (top to bottom)
                // Note: We use worldMap.length - 1 - latIndex to flip the y-axis since worldMap is stored top to bottom
                const latIndex = Math.min(worldMap.length - 1, Math.max(0, Math.floor((90 - lat) * worldMap.length / 180)));
                const lonIndex = Math.min(worldMap[0].length - 1, Math.max(0, Math.floor((lon + 180) * worldMap[0].length / 360)));
                
                return worldMap[latIndex][lonIndex] === '1';
            }
            
            // Create points in a more even distribution using the Fibonacci lattice
            // This avoids concentration at the poles
            const numPoints = CONFIG.numPoints; // Use configurable number of points
            
            // First pass: count how many land points we'll have
            const landPositions = [];
            const landNormals = [];
            const landData = [];
            
            for (let i = 0; i < numPoints; i++) {
                // Fibonacci lattice formula for even distribution on a sphere
                const phi = Math.acos(1 - 2 * (i + 0.5) / numPoints);
                const theta = Math.PI * (1 + Math.sqrt(5)) * (i + 0.5);
                
                // Convert to lat/lon
                const lat = 90 - (phi * 180 / Math.PI);
                const lon = (theta * 180 / Math.PI) % 360 - 180;
                
                // Only place a dot if the map indicates land
                if (isLand(lat, lon)) {
                    // Convert lat/lon to 3D coordinates
                    // Note the negative sign on x to correctly orient the globe
                    const phi = (90 - lat) * Math.PI / 180;
                    const theta = (lon + 180) * Math.PI / 180;
                    
                    // Lift the points slightly off the globe's surface for better visibility
                    const pointRadius = radius * 1.005; // 0.5% larger than globe radius
                    const x = -pointRadius * Math.sin(phi) * Math.cos(theta);
                    const y = pointRadius * Math.cos(phi);
                    const z = pointRadius * Math.sin(phi) * Math.sin(theta);
                    
                    // Store position and normal for instancing
                    landPositions.push(x, y, z);
                    
                    // Normal is just the normalized position for a sphere
                    const normal = new THREE.Vector3(x, y, z).normalize();
                    landNormals.push(normal.x, normal.y, normal.z);
                    
                    // Store additional data for hover effects
                    landData.push({
                        originalPosition: new THREE.Vector3(x, y, z),
                        hovering: false,
                        phi: phi,
                        theta: theta
                    });
                }
            }
            
            // Now we know how many dots we need
            const instanceCount = landPositions.length / 3;
            console.log(`Creating ${instanceCount} land dots`);
            
            if (instanceCount > 0) {
                // Create instanced mesh for much better performance
                const instancedDots = new THREE.InstancedMesh(dotGeometry, dotMaterial, instanceCount);
                instancedDots.count = instanceCount;
                
                // Create matrix and quaternion for positioning instances
                const matrix = new THREE.Matrix4();
                const quaternion = new THREE.Quaternion();
                const position = new THREE.Vector3();
                const scale = new THREE.Vector3(1, 1, 1);
                
                // Set instance matrices
                for (let i = 0; i < instanceCount; i++) {
                    // Get position
                    position.set(
                        landPositions[i * 3],
                        landPositions[i * 3 + 1],
                        landPositions[i * 3 + 2]
                    );
                    
                    // Calculate rotation to face outward
                    const normal = new THREE.Vector3(
                        landNormals[i * 3],
                        landNormals[i * 3 + 1],
                        landNormals[i * 3 + 2]
                    );
                    
                    // Use lookAt to orient the dot correctly
                    const lookAt = new THREE.Vector3().copy(position).add(normal);
                    const up = new THREE.Vector3(0, 1, 0);
                    const rotationMatrix = new THREE.Matrix4().lookAt(position, lookAt, up);
                    quaternion.setFromRotationMatrix(rotationMatrix);
                    
                    // Create transformation matrix
                    matrix.compose(position, quaternion, scale);
                    instancedDots.setMatrixAt(i, matrix);
                    
                    // Store data for hover (we'll handle this differently now)
                    const dot = {
                        index: i,
                        position: position.clone(),
                        originalPosition: position.clone(),
                        userData: landData[i]
                    };
                    landPoints.push(dot);
                }
                
                // Update the instance matrices
                instancedDots.instanceMatrix.needsUpdate = true;
                
                // Add to scene
                landDots.add(instancedDots);
                landDots.userData.instancedDots = instancedDots;
            }
            
            // Store the positions and normals arrays for hover effects
            landDots.userData.positions = landPositions;
            landDots.userData.normals = landNormals;
        }
        
        createLandPoints();
        console.timeEnd('landPoints');
        console.log(`Created ${landPoints.length} land points`);
        
        // Arcs between points
        const arcs = [];
        
        function createArc(startPoint, endPoint) {
            const startPos = startPoint.position.clone();
            const endPos = endPoint.position.clone();
            
            // Calculate a curved path between points
            const midPoint = startPos.clone().add(endPos).multiplyScalar(0.5);
            const distance = startPos.distanceTo(endPos);
            
            // Make the arc height relative to distance but ensure it touches the globe
            // Height of the arc depends on distance but is more rounded
            midPoint.normalize().multiplyScalar(radius + distance * 1.2); // Higher, more rounded arcs
            
            // Slightly adjust start and end points to ensure arcs touch the globe
            const adjustStartPos = startPos.clone().normalize().multiplyScalar(radius * 0.997);
            const adjustEndPos = endPos.clone().normalize().multiplyScalar(radius * 0.997);
            
            // Calculate all points for the complete path
            const allPoints = [];
            
            // Create more points at the start and end of the path for smoother animations
            // This creates a denser point distribution at both ends of the arc
            for (let i = 0; i <= CONFIG.arcPointsCount; i++) { // Use configurable point count
                // Apply non-linear distribution to create more points at the beginning and end
                // Use a modified sine curve to create denser sampling at both ends
                let t;
                if (i === 0) {
                    t = 0;
                } else if (i === CONFIG.arcPointsCount) {
                    t = 1;
                } else {
                    // Use an easing function that creates more points at the start and end
                    // This is a sine-based distribution function that clusters points at both ends
                    const normalizedI = i / CONFIG.arcPointsCount;
                    t = (Math.sin((normalizedI - 0.5) * Math.PI) + 1) / 2;
                }
                
                const point = new THREE.Vector3();
                
                if (i === 0) {
                    // Use adjusted start position for first point to touch globe
                    point.copy(adjustStartPos);
                } else if (i === CONFIG.arcPointsCount) {
                    // Use adjusted end position for last point to touch globe
                    point.copy(adjustEndPos);
                } else {
                    // Use cubic Bezier curve for smoother arcs
                    // Create two control points for better rounding
                    const cp1 = new THREE.Vector3().lerpVectors(adjustStartPos, midPoint, 0.3);
                    const cp2 = new THREE.Vector3().lerpVectors(midPoint, adjustEndPos, 0.7);
                    
                    // Cubic Bezier formula
                    const u = 1 - t;
                    const tt = t * t;
                    const uu = u * u;
                    const uuu = uu * u;
                    const ttt = tt * t;
                    
                    point.x = uuu * adjustStartPos.x + 3 * uu * t * cp1.x + 3 * u * tt * cp2.x + ttt * adjustEndPos.x;
                    point.y = uuu * adjustStartPos.y + 3 * uu * t * cp1.y + 3 * u * tt * cp2.y + ttt * adjustEndPos.y;
                    point.z = uuu * adjustStartPos.z + 3 * uu * t * cp1.z + 3 * u * tt * cp2.z + ttt * adjustEndPos.z;
                }
                
                allPoints.push(point);
            }
            
            // For initial creation, use multiple points to make a smoother initial tube
            // Using more points at the start creates a smoother initial appearance
            const initialPoints = [allPoints[0], allPoints[1], allPoints[2], allPoints[3]];
            const tubePath = new THREE.CatmullRomCurve3(initialPoints);
            tubePath.tension = 0.5; // Set tension for smoother curve
            
            // Create a tube geometry with smoother settings
            const tubeGeometry = new THREE.TubeGeometry(
                tubePath, 
                3, // Use more segments for smoother initial appearance
                CONFIG.arcThickness, 
                CONFIG.arcRadialSegments, 
                false
            ); // Use configurable settings
            
            // Randomly select two colors from the color palette for the gradient
            const colorIndex1 = Math.floor(Math.random() * CONFIG.arcColors.length);
            let colorIndex2 = Math.floor(Math.random() * CONFIG.arcColors.length);
            // Make sure we pick two different colors
            while (colorIndex2 === colorIndex1) {
                colorIndex2 = Math.floor(Math.random() * CONFIG.arcColors.length);
            }
            
            const startColor = new THREE.Color(CONFIG.arcColors[colorIndex1]);
            const endColor = new THREE.Color(CONFIG.arcColors[colorIndex2]);
            
            // Use a gradient texture for the arc color with enhanced transition
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 1;
            const context = canvas.getContext('2d');
            
            // Create a linear gradient with smoother transition
            const gradient = context.createLinearGradient(0, 0, canvas.width, 0);
            
            // Improve gradient with more color stops for richer transition
            // Start with the pure start color
            gradient.addColorStop(0, '#' + startColor.getHexString());
            
            // Add a 25% blend for smoother transition
            const quarterBlend = new THREE.Color().lerpColors(startColor, endColor, 0.25);
            gradient.addColorStop(0.3, '#' + quarterBlend.getHexString());
            
            // Add a 75% blend for smoother transition
            const threeQuarterBlend = new THREE.Color().lerpColors(startColor, endColor, 0.75);
            gradient.addColorStop(0.7, '#' + threeQuarterBlend.getHexString());
            
            // End with the pure end color
            gradient.addColorStop(1, '#' + endColor.getHexString());
            
            // Fill the canvas with the enhanced gradient
            context.fillStyle = gradient;
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Create a texture from the canvas
            const gradientTexture = new THREE.CanvasTexture(canvas);
            gradientTexture.needsUpdate = true;
            
            // Create the tube material with the gradient texture and improved settings
            const tubeMaterial = new THREE.MeshBasicMaterial({
                opacity: 0.9, // Increased opacity for better contrast against darker globe
                transparent: true,
                depthWrite: false, // Disable depth writing for better blending
                blending: THREE.AdditiveBlending, // Use additive blending for a glowing effect
                toneMapped: false, // Disable tone mapping for brighter appearance
                map: gradientTexture // Apply the gradient texture
            });
            
            // Create the mesh and add to globe group
            const arc = new THREE.Mesh(tubeGeometry, tubeMaterial);
            globeGroup.add(arc);
            
            return {
                arc: arc,
                tubeMaterial: tubeMaterial,
                allPoints: allPoints,
                progress: 0,
                growDuration: CONFIG.arcGrowDuration + Math.random() * 0.4, // Configurable growth time
                maxLife: CONFIG.arcRetreatDuration + Math.random() * 0.8, // Configurable retreat time
                age: 0,
                destinationPoint: endPos.clone(), // Store the destination point for impact effect
                impactCreated: false, // Flag to track if impact effect has been created
                startColor: startColor, // Store the start color for reference
                endColor: endColor // Store the end color for impact effect
            };
        }
        
        // Create explosion effect at arc destinations
        function createImpactEffect(position, color) {
            // Use the provided color or default to cyan if no color is passed
            const impactColor = color || new THREE.Color(0x88eeff);
            
            // Create a ring (bordered circle) that will expand outward
            const ringGeometry = new THREE.RingGeometry(
                0.045, // Inner radius - creates the border effect
                0.05,  // Outer radius
                24     // More segments for a smoother ring
            );
            const circleMaterial = new THREE.MeshBasicMaterial({
                color: impactColor, // Use the arc's end color
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.95, // Slightly higher opacity for better visibility of the thin ring
                depthWrite: false, // Disable depth writing for better blending
                blending: THREE.AdditiveBlending, // Use additive blending for glow effect
                toneMapped: false // Disable tone mapping for brighter appearance
            });
            
            const circle = new THREE.Mesh(ringGeometry, circleMaterial);
            
            // Position at the destination point
            circle.position.copy(position);
            
            // Make circle face outward from globe center
            circle.lookAt(new THREE.Vector3(0, 0, 0));
            
            // Add to globe group
            globeGroup.add(circle);
            
            // Create a secondary outer ring with a lighter version of the impact color
            const outerRingGeometry = new THREE.RingGeometry(
                0.065, // Inner radius
                0.075, // Outer radius - creates a larger border
                24     // More segments for a smoother ring
            );
            
            // Create a lighter but still colorful version of the impact color for the outer circle
            const lightenedColor = impactColor.clone().lerp(new THREE.Color(0xffffff), 0.4);
            
            const outerCircleMaterial = new THREE.MeshBasicMaterial({
                color: lightenedColor, // Lighter version of impact color
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.75, // Slightly increased opacity for better visibility of the thin ring
                depthWrite: false, // Disable depth writing for better blending
                blending: THREE.AdditiveBlending, // Use additive blending for glow effect
                toneMapped: false // Disable tone mapping for brighter appearance
            });
            
            const outerCircle = new THREE.Mesh(outerRingGeometry, outerCircleMaterial);
            
            // Position at the destination point but slightly behind the inner circle
            outerCircle.position.copy(position);
            
            // Move it slightly toward the globe to avoid z-fighting
            const directionToCenter = new THREE.Vector3(0, 0, 0).sub(position).normalize();
            outerCircle.position.add(directionToCenter.multiplyScalar(0.01));
            
            // Make circle face outward from globe center
            outerCircle.lookAt(new THREE.Vector3(0, 0, 0));
            
            // Add to globe group
            globeGroup.add(outerCircle);
            
            // Return object with properties for animation
            return {
                circle: circle,
                circleMaterial: circleMaterial,
                outerCircle: outerCircle,
                outerCircleMaterial: outerCircleMaterial,
                age: 0,
                maxLife: 0.5 + Math.random() * 0.3,  // Shorter lifespan (0.5-0.8 seconds)
                startTime: performance.now() / 1000  // Current time in seconds
            };
        }
        
        // Store active impact effects
        const impactEffects = [];
        
        // Randomly create arcs
        function addRandomArc() {
            if (landPoints.length < 2) return;
            
            const startIndex = Math.floor(Math.random() * landPoints.length);
            const startPoint = landPoints[startIndex];
            
            // Find suitable endpoints for the arc
            const candidatePoints = [];
            
            // Collect all points within suitable distance range
            // We want a good mix of short, medium and long paths
            for (let i = 0; i < landPoints.length; i++) {
                if (i !== startIndex) {
                    const dist = startPoint.position.distanceTo(landPoints[i].position);
                    // Wider distance range to allow for more varied arcs
                    if (dist > radius * 0.25 && dist < radius * 1.6) {
                        // Calculate a score that prefers points farther away from existing arcs
                        // This prevents clustering of arcs in the same area
                        let proximityScore = 1.0;
                        
                        // Check proximity to existing arc endpoints
                        for (const arc of arcs) {
                            const distToArc = landPoints[i].position.distanceTo(arc.destinationPoint);
                            if (distToArc < radius * 0.3) {
                                // Reduce score for points close to existing arcs
                                proximityScore *= 0.7;
                            }
                        }
                        
                        candidatePoints.push({
                            index: i,
                            distance: dist,
                            score: proximityScore
                        });
                    }
                }
            }
            
            // Select endpoint based on both distance and distribution
            let endPointIndex = -1;
            if (candidatePoints.length > 0) {
                // Sort by a combination of distance and proximity score
                // This creates more evenly distributed arcs around the globe
                candidatePoints.sort((a, b) => {
                    // Use normalized distance (0-1 range) * proximity score
                    const aScore = (a.distance / (radius * 1.6)) * a.score;
                    const bScore = (b.distance / (radius * 1.6)) * b.score;
                    // Randomize slightly to prevent predictable patterns
                    return (aScore + Math.random() * 0.1) - (bScore + Math.random() * 0.1);
                });
                
                // Take top 40% for more varied selection
                const topCount = Math.max(1, Math.floor(candidatePoints.length * 0.4));
                const randomIndex = Math.floor(Math.random() * topCount);
                endPointIndex = candidatePoints[randomIndex].index;
            }
            
            if (endPointIndex !== -1) {
                const endPoint = landPoints[endPointIndex];
                const arc = createArc(startPoint, endPoint);
                arcs.push(arc);
            }
        }
        
        // Raycaster for hover detection
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Variables for mouse rotation
        const mouseRotationSpeed = 0.01; // Keep this separate from auto-rotation
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let globeRotation = { x: 0, y: 0 };
        
        // Handle mouse movement
        function onMouseMove(event) {
            // Update mouse position for raycaster (hover effects)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Handle rotation when dragging
            if (isDragging) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;
                
                globeRotation.y += deltaX * mouseRotationSpeed;
                globeRotation.x += deltaY * mouseRotationSpeed;
                
                // Limit vertical rotation to prevent flipping
                globeRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, globeRotation.x));
                
                // Apply rotation to the entire globe group
                globeGroup.rotation.y = globeRotation.y;
                globeGroup.rotation.x = globeRotation.x;
            }
            
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }
        
        // Handle mouse down - start dragging
        function onMouseDown(event) {
            // Only drag with left mouse button
            if (event.button === 0) {
                isDragging = true;
                previousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
                // Change cursor
                document.body.style.cursor = 'grabbing';
            }
        }
        
        // Handle mouse up - stop dragging
        function onMouseUp() {
            isDragging = false;
            // Reset cursor
            document.body.style.cursor = 'auto';
        }
        
        // Add event listeners
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mouseup', onMouseUp);
        window.addEventListener('mouseleave', onMouseUp);
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        window.addEventListener('resize', onWindowResize);
        
        // Animation loop
        let lastArcTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);
            
            // Convert time to seconds
            const seconds = time / 1000;
            
            // Only auto-rotate if not being dragged - slower rotation for performance
            if (!isDragging) {
                // Use frame skipping for better performance if configured
                if (Math.floor(seconds * 30) % (CONFIG.skipFrames + 1) === 0) {
                    globeRotation.y += CONFIG.rotationSpeed;
                    globeGroup.rotation.y = globeRotation.y;
                }
            }
            
            // Atmospheric glow is now handled by inner glow sphere and lighting
            
            // Enhanced pulsing to the lights for dramatic glow effect
            // Optimize light updates by using a longer interval for subtle effects
            // This significantly reduces performance impact of light calculations
            if (Math.floor(seconds * 10) % 4 === 0) {
                const elapsedTime = seconds % 10;
                const primaryPulse = Math.sin(elapsedTime * Math.PI / 5) * 0.07 + 1.0;
                const secondaryPulse = Math.sin((elapsedTime + 2.5) * Math.PI / 5) * 0.05 + 1.0; // Out of phase
                
                // Pulse each light with different intensities and phases for more complex effect
                backLight.intensity = 3.5 * primaryPulse;
                rimLight.intensity = 1.8 * secondaryPulse;
                secondBackLight.intensity = 2.2 * secondaryPulse;
                thirdBackLight.intensity = 1.8 * primaryPulse;
                
                // Also pulse the inner glow opacity for enhanced effect
                innerGlowMaterial.opacity = 0.15 * (primaryPulse * 0.8 + 0.6);
                
                // Animate the atmosphere with better glow effect
                // Pulse the opacity for subtle breathing effect
                if (globeGroup.userData.atmosphere && globeGroup.userData.atmosphere.material) {
                    // Adjust the opacity for subtle pulsing
                    globeGroup.userData.atmosphere.material.opacity = 
                        CONFIG.atmosphereOpacity * (primaryPulse * 0.2 + 0.9);
                    
                    // Animate emissive intensity for changing glow
                    globeGroup.userData.atmosphere.material.emissiveIntensity = 
                        0.8 * (secondaryPulse * 0.3 + 0.85);
                    
                    // Slightly vary the color for a more natural effect
                    const hue = 0.6 + (primaryPulse * 0.015); // Subtle hue shift in blue range
                    const color = new THREE.Color().setHSL(hue, 0.8, 0.6);
                    globeGroup.userData.atmosphere.material.emissive.copy(color);
                }
                
                // Animate the dedicated atmosphere light for stronger effect
                if (globeGroup.userData.atmosphereLight) {
                    // Pulse the light intensity
                    globeGroup.userData.atmosphereLight.intensity = 
                        CONFIG.atmosphereGlow * (secondaryPulse * 0.4 + 0.8);
                    
                    // Move the light slightly for dynamic shadows
                    const lightAngle = elapsedTime * 0.5;
                    const lightRadius = radius * 0.1; // Small orbit radius
                    globeGroup.userData.atmosphereLight.position.set(
                        Math.sin(lightAngle) * lightRadius,
                        Math.cos(lightAngle * 0.8) * lightRadius,
                        Math.sin(lightAngle * 1.2) * lightRadius
                    );
                }
            }
            
            // Add random arcs more aggressively to ensure continuous flow
            if ((seconds - lastArcTime > CONFIG.arcFrequency + (Math.random() * CONFIG.arcTimingVariation)) || 
                // Force arc creation if we're significantly below the maximum
                (arcs.length < CONFIG.maxConcurrentArcs * 0.7 && seconds - lastArcTime > 0.1)) {
                addRandomArc();
                lastArcTime = seconds;
            }
            
            // Only update arcs and impact effects on appropriate frames based on skipFrames
            // Skip frames based on configuration for better performance
            if (Math.floor(seconds * 30) % (CONFIG.skipFrames + 1) === 0) {
                // Update arcs
                for (let i = arcs.length - 1; i >= 0; i--) {
                    const arc = arcs[i];
                    arc.age += 0.02; // Normal increment for smooth animation
                
                // During growth phase - extend the arc
                if (arc.age < arc.growDuration) {
                    // Calculate how far along the growth we are (0 to 1) with easing function
                    let growthProgress = arc.age / arc.growDuration;
                    
                    // Apply easing function for smoother growth (easeInOutQuad)
                    if (growthProgress < 0.5) {
                        growthProgress = 2 * growthProgress * growthProgress;
                    } else {
                        growthProgress = -1 + (4 - 2 * growthProgress) * growthProgress;
                    }
                    
                    // If we've reached 90% of the growth and haven't created an impact effect yet
                    if (growthProgress >= 0.9 && !arc.impactCreated) {
                        // Create impact effect at destination with the arc's end color
                        impactEffects.push(createImpactEffect(arc.destinationPoint, arc.endColor));
                        arc.impactCreated = true; // Mark that we've created the impact
                    }
                    
                    // Calculate how many points should be visible
                    const pointCount = Math.max(2, Math.floor(growthProgress * arc.allPoints.length));
                    
                    // Get current visible points
                    const currentPoints = arc.allPoints.slice(0, pointCount);
                    
                    try {
                        // Create new tube geometry with current points
                        const tubePath = new THREE.CatmullRomCurve3(currentPoints);
                        
                        // Apply lower tension for smoother, rounder curves during growth
                        tubePath.tension = 0.4;
                        
                        // Calculate dynamic segments for better quality during growth
                        const dynamicSegments = Math.max(
                            5, 
                            Math.min(
                                CONFIG.arcTubeSegments, 
                                Math.ceil(pointCount * 0.8) // Scale segments with curve length for smoother curves
                            )
                        );
                        
                        const newTubeGeometry = new THREE.TubeGeometry(
                            tubePath, 
                            dynamicSegments, // More segments for smoother appearance
                            CONFIG.arcThickness, // Configurable thickness
                            CONFIG.arcRadialSegments, 
                            false
                        );
                        
                        // Remove old mesh from globe group
                        globeGroup.remove(arc.arc);
                        
                        // Dispose old geometry to prevent memory leaks
                        if (arc.arc.geometry) {
                            arc.arc.geometry.dispose();
                        }
                        
                        // Replace with new geometry
                        arc.arc.geometry = newTubeGeometry;
                        
                        // Add back to globe group
                        globeGroup.add(arc.arc);
                    } catch(e) {
                        // If there's an error, just skip this frame
                        console.log("Arc animation error", e);
                    }
                    
                    arc.tubeMaterial.opacity = 0.7; // Full opacity during growth
                }
                // Retreat arcs after growing - line leaves from origin point
                else if (arc.age > arc.growDuration) {
                    // Calculate retreat progress (0 to 1) with improved easing
                    let retreatProgress = Math.min(1, (arc.age - arc.growDuration) / arc.maxLife);
                    
                    // Apply custom easing function for smoother retreat
                    // This creates a slow start, fast middle, and slow end
                    retreatProgress = Math.pow(retreatProgress, 2) * (3 - 2 * retreatProgress);
                    
                    // Apply additional easing at the beginning for an even smoother start
                    if (retreatProgress < 0.2) {
                        retreatProgress = retreatProgress * retreatProgress * 5;
                    }
                    
                    // Calculate how many points should be visible as the line retreats
                    // Use non-linear mapping for smoother retreat
                    const startIndex = Math.floor(retreatProgress * arc.allPoints.length);
                    const pointCount = arc.allPoints.length - startIndex;
                    
                    // Skip if too few points remain
                    if (pointCount < 2) {
                        // Skip rendering when almost gone
                        arc.tubeMaterial.opacity = 0;
                        continue;
                    }
                    
                    // Get current visible points - shifting starting position as line retreats
                    const currentPoints = arc.allPoints.slice(startIndex);
                    
                    try {
                        // Create new tube geometry with retreating points
                        const tubePath = new THREE.CatmullRomCurve3(currentPoints);
                        
                        // Apply lower tension for smoother, rounder curves during retreat
                        tubePath.tension = 0.4;
                        
                        // Use higher segment count for smoother retreating appearance
                        const dynamicSegments = Math.max(
                            5, 
                            Math.min(
                                CONFIG.arcTubeSegments, 
                                Math.ceil(pointCount * 0.9) // Higher scaling for retreat for smoother curves
                            )
                        );
                        
                        const newTubeGeometry = new THREE.TubeGeometry(
                            tubePath, 
                            dynamicSegments,
                            // Gradually thin the arc as it retreats for a more elegant disappearance
                            CONFIG.arcThickness * (1 - (retreatProgress * 0.3)), // More pronounced thinning during retreat
                            CONFIG.arcRadialSegments,
                            false
                        );
                        
                        // Remove old mesh from globe group
                        globeGroup.remove(arc.arc);
                        
                        // Dispose old geometry to prevent memory leaks
                        if (arc.arc.geometry) {
                            arc.arc.geometry.dispose();
                        }
                        
                        // Replace with new geometry
                        arc.arc.geometry = newTubeGeometry;
                        
                        // Add back to globe group
                        globeGroup.add(arc.arc);
                    } catch(e) {
                        // If there's an error, just skip this frame
                        console.log("Arc retreat animation error", e);
                    }
                }
                
                // Remove old arcs
                if (arc.age >= arc.growDuration + arc.maxLife) {
                    globeGroup.remove(arc.arc);
                    arc.arc.geometry.dispose();
                    arcs.splice(i, 1);
                }
            }
            
            // Update impact effects
            for (let i = impactEffects.length - 1; i >= 0; i--) {
                const effect = impactEffects[i];
                effect.age += 0.02; // Match arc update rate
                
                if (effect.age < effect.maxLife) {
                    // Calculate current size based on age (expand over time)
                    const progress = effect.age / effect.maxLife;
                    
                    // Inner circle - expands over time but stays smaller
                    const innerRadius = progress * radius * CONFIG.impactSize; // Use configurable impact size
                    
                    // Update inner circle geometry
                    globeGroup.remove(effect.circle);
                    if (effect.circle.geometry) {
                        effect.circle.geometry.dispose();
                    }
                    
                    // Create new ring geometry with updated size
                    // Keep the ring border width proportional to its size
                    const borderWidth = innerRadius * 0.2; // Border is 20% of the radius
                    const newGeometry = new THREE.RingGeometry(
                        innerRadius - borderWidth, // Inner radius of the ring 
                        innerRadius,               // Outer radius of the ring
                        24                         // More segments for a smoother ring
                    );
                    effect.circle.geometry = newGeometry;
                    
                    // Update inner circle opacity (fade out towards the end)
                    effect.circleMaterial.opacity = Math.max(0, 0.8 * (1 - Math.pow(progress, 1.5)));
                    
                    // Add back to scene
                    globeGroup.add(effect.circle);
                    
                    // Outer circle (expands faster)
                    const outerRadius = innerRadius * 1.3; // 30% larger than inner circle
                    
                    // Update outer circle geometry
                    globeGroup.remove(effect.outerCircle);
                    if (effect.outerCircle.geometry) {
                        effect.outerCircle.geometry.dispose();
                    }
                    
                    // Create new outer ring geometry with updated size
                    // Keep the ring border width proportional to its size
                    const outerBorderWidth = outerRadius * 0.15; // Slightly thinner border for outer ring
                    const newOuterGeometry = new THREE.RingGeometry(
                        outerRadius - outerBorderWidth, // Inner radius of the ring
                        outerRadius,                    // Outer radius of the ring
                        24                              // More segments for a smoother ring
                    );
                    effect.outerCircle.geometry = newOuterGeometry;
                    
                    // Update outer circle opacity (fade out faster)
                    effect.outerCircleMaterial.opacity = Math.max(0, 0.6 * (1 - Math.pow(progress, 2)));
                    
                    // Add back to scene
                    globeGroup.add(effect.outerCircle);
                    
                    // Move slightly behind to avoid z-fighting as they grow
                    const directionToCenter = new THREE.Vector3(0, 0, 0).sub(effect.outerCircle.position).normalize();
                    effect.outerCircle.position.copy(effect.circle.position);
                    effect.outerCircle.position.add(directionToCenter.multiplyScalar(0.01));
                    
                    // Make sure the circles face outward
                    effect.circle.lookAt(new THREE.Vector3(0, 0, 0));
                    effect.outerCircle.lookAt(new THREE.Vector3(0, 0, 0));
                } else {
                    // Smoother transition at the end of effect - fade to zero before removing
                    if (effect.circleMaterial.opacity > 0.05) {
                        // Rapidly fade out remaining opacity
                        effect.circleMaterial.opacity *= 0.7;
                        effect.outerCircleMaterial.opacity *= 0.7;
                        
                        // Skip to next iteration but don't remove the effect yet
                        continue;
                    }
                    
                    // Remove old impact effects - inner circle
                    globeGroup.remove(effect.circle);
                    if (effect.circle.geometry) {
                        effect.circle.geometry.dispose();
                    }
                    effect.circleMaterial.dispose();
                    
                    // Remove outer circle
                    globeGroup.remove(effect.outerCircle);
                    if (effect.outerCircle.geometry) {
                        effect.outerCircle.geometry.dispose();
                    }
                    effect.outerCircleMaterial.dispose();
                    
                    impactEffects.splice(i, 1);
                }
                }
            } // Close the frame skipping condition
            
            // Hover effects for land points
            if (!isDragging) {
                // Cast a ray from the mouse position
                raycaster.setFromCamera(mouse, camera);
                
                // Check if the ray intersects with the globe
                const globeIntersects = raycaster.intersectObject(globe);
                
                if (globeIntersects.length > 0) {
                    // Get the intersection point on the globe in local coordinates
                    // This is critical to account for the globe's rotation
                    const currentIntersectionPoint = globeIntersects[0].point.clone();
                    
                    // Convert world coordinates to globe's local coordinates
                    // This accounts for the globe rotation
                    globeGroup.worldToLocal(currentIntersectionPoint);
                    
                    // Store a static reference for the intersection point
                    if (!window.lastIntersectionPoint) {
                        window.lastIntersectionPoint = currentIntersectionPoint.clone();
                    }
                    
                    // More responsive transition for the focused hover effect
                    // Increase the lerp factor for quicker response while still maintaining some smoothing
                    window.lastIntersectionPoint.lerp(currentIntersectionPoint, 0.3); // Higher interpolation factor for faster response
                    
                    // Use the smoothed intersection point
                    const intersectionPoint = window.lastIntersectionPoint;
                    
                    // Reference to the instanced dots
                    const instancedDots = landDots.userData.instancedDots;
                    
                    // Calculate hover effects for all land points based on distance
                    if (instancedDots) {
                        // Create a new Matrix4 and Quaternion for updating dots
                        const matrix = new THREE.Matrix4();
                        const quaternion = new THREE.Quaternion();
                        const position = new THREE.Vector3();
                        const scale = new THREE.Vector3(1, 1, 1);
                        
                        // For the more focused hover effect, we need dense point processing in the hover area
                        // Even in high performance mode, we process all points for consistency
                        const skipPoints = 1; // Never skip points for more precise hover effect
                        
                        for (let i = 0; i < landPoints.length; i += skipPoints) {
                            const dot = landPoints[i];
                            
                            // Get original position
                            const originalPos = dot.originalPosition;
                            
                            // Calculate distance to intersection point
                            const distance = originalPos.distanceTo(intersectionPoint);
                            
                            // Convert distance to an effect factor
                            // Closer points should rise more, with a much tighter, localized falloff
                            const maxDistance = radius * CONFIG.hoverPull; // Significantly reduced max distance for a much more focused effect
                            
                            if (distance < maxDistance) {
                                // Calculate a much more focused hover effect with steeper falloff
                                // Use a sharper exponential curve for more localized effect
                                const normalizedDist = distance / maxDistance;
                                
                                // Create a steeper falloff using higher power exponent
                                // This will make the effect drop off much more quickly with distance
                                const bellCurve = Math.cos(normalizedDist * Math.PI * 0.5);
                                const exponentialFalloff = Math.pow(bellCurve, 4); // Higher power for much steeper falloff
                                const smoothFactor = exponentialFalloff * CONFIG.hoverEffect * 1.5; // Slightly intensify the center effect
                                
                                // Apply hover effect - move dot outward from globe center
                                const direction = originalPos.clone().normalize();
                                const newPosition = originalPos.clone().add(
                                    direction.multiplyScalar(radius * smoothFactor)
                                );
                                
                                // Update matrix for this instance
                                position.copy(newPosition);
                                
                                // Orient dot to face outward
                                const normal = newPosition.clone().normalize();
                                const lookAt = position.clone().add(normal);
                                const up = new THREE.Vector3(0, 1, 0);
                                const rotationMatrix = new THREE.Matrix4().lookAt(position, lookAt, up);
                                quaternion.setFromRotationMatrix(rotationMatrix);
                                
                                // Create matrix in local coordinates
                                matrix.compose(position, quaternion, scale);
                                
                                // Set matrix in local space - globeGroup rotation is automatically applied
                                instancedDots.setMatrixAt(dot.index, matrix);
                            }
                            else {
                                // Reset to original position if not affected
                                position.copy(originalPos);
                                
                                // Orient dot to face outward
                                const normal = originalPos.clone().normalize();
                                const lookAt = position.clone().add(normal);
                                const up = new THREE.Vector3(0, 1, 0);
                                const rotationMatrix = new THREE.Matrix4().lookAt(position, lookAt, up);
                                quaternion.setFromRotationMatrix(rotationMatrix);
                                
                                // Create matrix in local coordinates
                                matrix.compose(position, quaternion, scale);
                                
                                // Set matrix in local space - globeGroup rotation is automatically applied
                                instancedDots.setMatrixAt(dot.index, matrix);
                            }
                        }
                        
                        // Update the instance matrices
                        instancedDots.instanceMatrix.needsUpdate = true;
                    }
                }
            }
            
            renderer.render(scene, camera);
        }
        
        // Function to initialize multiple arcs at startup
        function initializeArcs() {
            // Create a initial batch of arcs to start with
            const initialArcCount = Math.floor(CONFIG.maxConcurrentArcs * 0.5); // Start with 50% of max arcs
            console.log(`Creating ${initialArcCount} initial arcs...`);
            
            // Create arcs with varied growth progress
            for (let i = 0; i < initialArcCount; i++) {
                // Create the arc
                addRandomArc();
                
                // Set random initial age so arcs don't all grow/fade simultaneously
                if (arcs.length > 0) {
                    const randomProgress = Math.random();
                    const arc = arcs[arcs.length - 1];
                    
                    // Set up initial age to have arcs in various stages
                    if (randomProgress < 0.7) {
                        // 70% of initial arcs in growth phase
                        arc.age = arc.growDuration * Math.random() * 0.9;
                    } else {
                        // 30% in retreat phase
                        arc.age = arc.growDuration + (Math.random() * arc.maxLife * 0.5);
                    }
                }
            }
        }
        
        // Initialize arcs before starting animation
        initializeArcs();
        
        // Start animation loop
        animate(0);
    </script>
</body>
</html>