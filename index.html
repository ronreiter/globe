<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Globe Visualization</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; cursor: grab; }
        canvas:active { cursor: grabbing; }
        
        /* Debug Panel Styles */
        #debug-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            font-family: monospace;
            font-size: 12px;
        }
        
        #fps-counter {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            border-radius: 4px;
            padding: 5px 10px;
            font-family: monospace;
            font-size: 12px;
            z-index: 100;
        }
        
        #debug-panel {
            position: fixed;
            top: 50px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            border-radius: 4px;
            padding: 15px;
            width: 300px;
            max-height: 80vh;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            display: none;
            z-index: 99;
        }
        
        #debug-panel h3 {
            margin: 0 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid #444;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group h4 {
            margin: 0 0 5px 0;
            color: #aaa;
        }
        
        .control-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .control-item label {
            flex: 1;
        }
        
        .control-item input, .control-item select {
            width: 50%;
            background: #222;
            color: #fff;
            border: 1px solid #444;
            padding: 3px;
        }
        
        .control-item input[type="checkbox"] {
            width: auto;
        }
        
        .control-item input[type="range"] {
            background: transparent;
        }
        
        /* Disable pointer events on canvas when interacting with debug panel */
        body.debug-panel-active canvas {
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="fps-counter">FPS: 0</div>
    <button id="debug-toggle">Debug Panel</button>
    <div id="debug-panel">
        <h3>Debug Controls</h3>
        
        <div class="control-group">
            <h4>Globe Appearance</h4>
            <div class="control-item">
                <label>Globe Radius</label>
                <input type="range" id="globeRadius" min="8" max="15" step="0.5" value="11">
            </div>
            <div class="control-item">
                <label>Globe Segments</label>
                <input type="range" id="globeSegments" min="16" max="128" step="8" value="64">
            </div>
            <div class="control-item">
                <label>Show Atmosphere</label>
                <input type="checkbox" id="showAtmosphere" checked>
            </div>
            <div class="control-item">
                <label>Atmosphere Opacity</label>
                <input type="range" id="atmosphereOpacity" min="0.05" max="0.5" step="0.01" value="0.18">
            </div>
            <div class="control-item">
                <label>Atmosphere Glow</label>
                <input type="range" id="atmosphereGlow" min="0.5" max="3" step="0.1" value="1.5">
            </div>
        </div>
        
        <div class="control-group">
            <h4>Land Points</h4>
            <div class="control-item">
                <label>Show Land Points</label>
                <input type="checkbox" id="showLandPoints" checked>
            </div>
            <div class="control-item">
                <label>Number of Points</label>
                <input type="range" id="numPoints" min="3000" max="50000" step="1000" value="50000">
            </div>
            <div class="control-item">
                <label>Dot Size</label>
                <input type="range" id="dotSize" min="0.01" max="0.2" step="0.01" value="0.05">
            </div>
            <div class="control-item">
                <label>Dot Opacity</label>
                <input type="range" id="dotOpacity" min="0.1" max="1.0" step="0.05" value="0.4">
            </div>
            <div class="control-item">
                <label>Hover Effect</label>
                <input type="range" id="hoverEffect" min="0.01" max="0.5" step="0.01" value="0.05">
            </div>
            <div class="control-item">
                <label>Disable Hover Processing</label>
                <input type="checkbox" id="disableHover">
            </div>
        </div>
        
        <div class="control-group">
            <h4>Arcs</h4>
            <div class="control-item">
                <label>Show Arcs</label>
                <input type="checkbox" id="showArcs" checked>
            </div>
            <div class="control-item">
                <label>Max Concurrent Arcs</label>
                <input type="range" id="maxConcurrentArcs" min="5" max="40" step="1" value="10">
            </div>
            <div class="control-item">
                <label>Arc Frequency</label>
                <input type="range" id="arcFrequency" min="0.1" max="1.0" step="0.05" value="0.4">
            </div>
            <div class="control-item">
                <label>Arc Thickness</label>
                <input type="range" id="arcThickness" min="0.01" max="0.1" step="0.002" value="0.038">
            </div>
            <div class="control-item">
                <label>Arc Points</label>
                <input type="range" id="arcPointsCount" min="10" max="100" step="5" value="80">
            </div>
        </div>
        
        <div class="control-group">
            <h4>Animation</h4>
            <div class="control-item">
                <label>Rotation Speed</label>
                <input type="range" id="rotationSpeed" min="0" max="0.01" step="0.0005" value="0.002">
            </div>
            <div class="control-item">
                <label>Arc Grow Duration</label>
                <input type="range" id="arcGrowDuration" min="0.3" max="2.5" step="0.1" value="1.3">
            </div>
            <div class="control-item">
                <label>Arc Retreat Duration</label>
                <input type="range" id="arcRetreatDuration" min="0.5" max="4.0" step="0.1" value="2.8">
            </div>
        </div>
        
        <div class="control-group">
            <h4>Rendering</h4>
            <div class="control-item">
                <label>High Performance Mode</label>
                <input type="checkbox" id="useHighPerformanceMode">
            </div>
            <div class="control-item">
                <label>Skip Frames</label>
                <input type="range" id="skipFrames" min="0" max="4" step="1" value="0">
            </div>
            <div class="control-item">
                <label>Pixel Ratio</label>
                <input type="range" id="pixelRatio" min="0.5" max="2" step="0.1" value="1">
            </div>
            <div class="control-item">
                <label>Disable Lights</label>
                <input type="checkbox" id="disableLights">
            </div>
            <div class="control-item">
                <label>Disable Animations</label>
                <input type="checkbox" id="freezeAnimations">
            </div>
            <div class="control-item">
                <label>Disable Auto-Rotation</label>
                <input type="checkbox" id="disableRotation">
            </div>
            <div class="control-item">
                <label>Uncap FPS</label>
                <input type="checkbox" id="uncapFps">
            </div>
            <div class="control-item">
                <label>Show Detailed Metrics</label>
                <input type="checkbox" id="showDetailedMetrics">
            </div>
        </div>
    </div>
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script>
        // Configuration parameters for performance/quality tradeoff
        const CONFIG = {
            backgroundColor: 0x081b2e,
            // Globe appearance
            globeRadius: 11,                  // Size of the globe
            globeSegments: 64,                // Resolution of the globe (32-128, lower for better performance)
            atmosphereSize: 1.00,             // Size of atmosphere relative to globe (1.1-1.5)
            atmosphereOpacity: 0.18,          // Opacity of atmosphere (0.1-0.5)
            atmosphereGlow: 1.5,              // Intensity of atmosphere glow effect (1.0-3.0)
            
            // Arc color palette (in hex format with adjusted brightness and more saturation)
            arcColors: [
                0xD02C34, // Deeper Red
                0xE9A23A, // Golden Yellow
                0x5494D4, // Richer Blue
                0x8A5BC8, // Deeper Purple
                0xCF3250, // Deeper Pink
                0x9240B3, // Rich Violet
                0xE06C33, // Burnt Orange
                0x50A0D8  // Azure Blue
            ],
            
            // Land points
            numPoints: 50000,                 // Maximum points to generate (3000-25000, lower for better performance)
            dotSize: 0.05,                    // Size of land dots (0.05-0.1)
            dotSegments: 6,                   // Land dot geometry segments (4-8, lower for better performance)
            dotOpacity: 0.4,                  // Opacity of land dots (0.1-1.0)
            hoverEffect: 0.05,                // Strength of dot hover effect (0.1-0.5)
            hoverPull: 0.45,                  // The focus of the hover effect
            
            // Arcs
            maxConcurrentArcs: 10,            // Maximum concurrent arcs (6-40, lower for better performance)
            arcFrequency: 0.4,                // How often new arcs appear (higher = less frequent)
            arcTimingVariation: 0.15,         // Randomness in arc timing (0-1, higher = more random)
            arcTubeSegments: 18,              // Maximum tube segments for arcs (6-18, lower for better performance) 
            arcRadialSegments: 6,             // Radial segments for arc tubes (3-8, lower for better performance)
            arcThickness: 0.038,              // Thickness of arcs (0.03-0.1)
            arcPointsCount: 80,               // Number of points in arc path (20-50, lower for better performance)
            
            // Animation and behavior
            rotationSpeed: 0.002,             // Speed of auto-rotation (0.001-0.003)
            arcGrowDuration: 1.3,             // Base duration for arc growth in seconds (0.5-1.5)
            arcRetreatDuration: 2.8,          // Base duration for arc retreat in seconds (0.8-3.0)
            
            // Impact effects
            impactSize: 0.05,                 // Maximum impact size as fraction of globe radius (0.05-0.2)
            bullseyeSize: 0.10,               // Size of bullseye center (0.1-0.3)
            bullseyeRingSize: 0.2,            // Size of bullseye outer ring (0.2-0.4)
            
            // Rendering
            useHighPerformanceMode: false,    // Set true for better performance but lower visual quality
            skipFrames: 0                     // Number of frames to skip when updating (0-2, higher for better performance)
        };        
        
        // Auto-detect performance capabilities and adjust settings if needed
        // This helps ensure smooth performance on all devices without manual toggling
        function autoDetectPerformance() {
            // Only run auto-detection if high performance mode isn't explicitly set
            if (CONFIG.useHighPerformanceMode === false) {
                // Check for mobile devices which typically have less GPU power
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                // Check if device has a lower resolution screen (proxy for lower-end device)
                const hasLowResScreen = window.screen.width * window.screen.height < 1920 * 1080;
                
                // Check for lower memory (another proxy for capability)
                const hasLowMemory = navigator.deviceMemory !== undefined && navigator.deviceMemory < 4;
                
                // Apply medium performance adjustments if device seems limited
                if (isMobile || hasLowResScreen || hasLowMemory) {
                    console.log("Auto-detected limited device capabilities, applying performance optimizations");
                    
                    // Reduce complexity but not as drastically as high performance mode
                    CONFIG.globeSegments = Math.max(32, CONFIG.globeSegments * 0.7);
                    CONFIG.numPoints = Math.max(15000, CONFIG.numPoints * 0.7);
                    CONFIG.dotOpacity = Math.max(0.6, CONFIG.dotOpacity * 0.85); // Reduce dot opacity for better performance
                    CONFIG.maxConcurrentArcs = Math.max(25, CONFIG.maxConcurrentArcs * 0.8);
                    CONFIG.arcPointsCount = Math.max(25, CONFIG.arcPointsCount * 0.8);
                    CONFIG.skipFrames = 1; // Skip every other frame
                    
                    // Apply pixel ratio limitation
                    if (window.devicePixelRatio > 2) {
                        renderer.setPixelRatio(1.5); // Cap pixel ratio for high-DPI screens
                    }
                }
            }
        }
        
        // Run auto-detection
        autoDetectPerformance();
        
        // Set up the scene, camera, and renderer
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(CONFIG.backgroundColor); 
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        // Create renderer with performance optimizations
        const renderer = new THREE.WebGLRenderer({ 
            antialias: CONFIG.useHighPerformanceMode, // Disable antialiasing in high performance mode
            powerPreference: "high-performance",
            precision: "mediump" // Use medium precision for shaders - major performance boost with minimal visual impact
        });
        
        // Optimize renderer for better performance
        renderer.sortObjects = false; // Disable object sorting since depth is relatively straightforward in this scene
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        // Set appropriate pixel ratio for performance without sacrificing quality too much
        const optimizedPixelRatio = CONFIG.useHighPerformanceMode ? 1 : 
                                   (window.devicePixelRatio > 2 ? 1.5 : window.devicePixelRatio);
        renderer.setPixelRatio(optimizedPixelRatio);
        
        // Additional optimizations
        renderer.shadowMap.enabled = false; // Disable shadow maps as we don't use them
        document.body.appendChild(renderer.domElement);
        
        // Create a single parent group for the entire globe and all its elements
        const globeGroup = new THREE.Group();
        scene.add(globeGroup);
        
        // Create a blue globe with enhanced material for better glow and performance
        const radius = CONFIG.globeRadius;  // Use configurable radius
        const globeGeometry = new THREE.SphereGeometry(
            radius, 
            CONFIG.globeSegments, 
            CONFIG.globeSegments
        ); 
        const globeMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x005280,      // Darker blue for the base color
            shininess: 15,        // Reduced shininess for a more muted appearance
            specular: 0x223344,   // Reduced specular for less bright highlights
            emissive: 0x002a56,   // Darker emissive glow
            transparent: true,    // Enable transparency
            opacity: 0.94         // Slightly more opaque for deeper appearance
        });
        const globe = new THREE.Mesh(globeGeometry, globeMaterial);
        globeGroup.add(globe);
        
        // Add a slightly larger inner glow sphere for enhanced glow effect
        const innerGlowGeometry = new THREE.SphereGeometry(
            radius * 1.01, 
            Math.max(16, Math.floor(CONFIG.globeSegments * 0.5)), // Lower resolution is fine for glow
            Math.max(16, Math.floor(CONFIG.globeSegments * 0.5))
        );
        const innerGlowMaterial = new THREE.MeshBasicMaterial({
            color: 0x003466,      // Darker blue for inner glow
            transparent: true,
            opacity: 0.13,        // Slightly less opacity
            side: THREE.BackSide  // Only show the inside
        });
        const innerGlow = new THREE.Mesh(innerGlowGeometry, innerGlowMaterial);
        globeGroup.add(innerGlow);
        
        // Add a single atmosphere with light-based glow effect
        const atmosphereSize = radius * CONFIG.atmosphereSize * 1.05; // Slightly larger for more extensive glow
        const atmosphereGeometry = new THREE.SphereGeometry(
            atmosphereSize,
            CONFIG.globeSegments, // Use same resolution as globe for smooth appearance
            CONFIG.globeSegments
        );
        
        // Create a custom shader material for the atmosphere halo effect
        const atmosphereMaterial = new THREE.ShaderMaterial({
            uniforms: {
                globeRadius: { value: radius },
                atmosphereRadius: { value: atmosphereSize },
                color: { value: new THREE.Color(0x4499ff) }, // Bright blue base color
                glowColor: { value: new THREE.Color(0x99bbff) }, // Brighter blue for more prominent edge glow
                opacity: { value: CONFIG.atmosphereOpacity * 1.5 }, // Increased for more visible glow
                power: { value: 2.0 }, // Controls the edge glow power (higher = sharper edge)
                time: { value: 0.0 } // For subtle animation
            },
            vertexShader: `
                varying vec3 vPosition;
                varying vec3 vNormal;
                varying vec3 vWorldPosition;
                
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vPosition = position;
                    vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float globeRadius;
                uniform float atmosphereRadius;
                uniform vec3 color;
                uniform vec3 glowColor;
                uniform float opacity;
                uniform float power;
                uniform float time;
                
                varying vec3 vPosition;
                varying vec3 vNormal;
                varying vec3 vWorldPosition;
                
                void main() {
                    // Calculate distance from camera/view vector
                    float intensity = pow(0.75 - dot(vNormal, vec3(0, 0, 1.0)), power);
                    
                    // Add time-based pulsing (enhanced)
                    float pulse = 1.0 + 0.15 * sin(time * 0.5);
                    
                    // Add secondary pulse for more complex movement
                    float secondaryPulse = 1.0 + 0.08 * sin(time * 0.8 + 1.5);
                    
                    // Create position-based variation
                    float positionEffect = sin(vWorldPosition.x * 0.2 + time * 0.3) * 
                                          cos(vWorldPosition.y * 0.2 + time * 0.2) *
                                          sin(vWorldPosition.z * 0.2 + time * 0.4);
                    
                    // Apply position-based intensity variation
                    intensity *= 1.0 + 0.2 * positionEffect;
                    
                    // Create the rim light/halo effect blended with base color
                    vec3 finalColor = mix(color, glowColor, intensity) * pulse * secondaryPulse;
                    
                    // Add subtle color variation based on position
                    finalColor.r += 0.1 * sin(vWorldPosition.y * 0.1 + time * 0.2);
                    finalColor.g += 0.05 * cos(vWorldPosition.z * 0.1 + time * 0.3);
                    finalColor.b += 0.15 * sin(vWorldPosition.x * 0.1 + time * 0.4);
                    
                    // Apply the glow with enhanced opacity falloff
                    gl_FragColor = vec4(finalColor, min(1.0, opacity * intensity * 2.0 * pulse));
                }
            `,
            side: THREE.BackSide,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        
        // Create the atmosphere mesh
        const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
        globeGroup.add(atmosphere);
        
        // Add a dedicated glow light at the center of the globe with increased intensity
        const atmosphereLight = new THREE.PointLight(0x5599ff, CONFIG.atmosphereGlow * 1.5, atmosphereSize * 4);
        atmosphereLight.position.set(0, 0, 0); // Centered
        globeGroup.add(atmosphereLight);
        
        // Add a second atmosphere light for enhanced glow effect
        const atmosphereLight2 = new THREE.PointLight(0x3377ff, CONFIG.atmosphereGlow * 0.8, atmosphereSize * 3.5);
        atmosphereLight2.position.set(radius * 0.2, -radius * 0.1, radius * 0.1); // Slightly offset
        globeGroup.add(atmosphereLight2);
        
        // Store references for animation
        globeGroup.userData.atmosphere = atmosphere;
        globeGroup.userData.atmosphereLight = atmosphereLight;
        globeGroup.userData.atmosphereLight2 = atmosphereLight2;
        globeGroup.userData.innerGlow = innerGlow;
        
        // Enhanced lighting for better glow and highlights
        const ambientLight = new THREE.AmbientLight(0x333344, 0.5); // Subtle bluish ambient light
        scene.add(ambientLight);
        
        // Main directional light (sun-like) - reduced intensity
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
        directionalLight.position.set(8, 8, 8);
        scene.add(directionalLight);
        
        // Enhanced blue backlight for stronger glow effect - significantly increased intensity
        const backLight = new THREE.PointLight(0x0077ff, 4.5, 75);
        backLight.position.set(-20, 8, -20);
        scene.add(backLight);
        
        // Second backlight with different color for more dramatic effect
        const secondBackLight = new THREE.PointLight(0x0022aa, 2.2, 60);
        secondBackLight.position.set(-18, -5, -15);
        scene.add(secondBackLight);
        
        // Third backlight with cyan tint for edge highlights
        const thirdBackLight = new THREE.PointLight(0x00aaff, 1.8, 55);
        thirdBackLight.position.set(-15, 12, -18);
        scene.add(thirdBackLight);
        
        // Blue rim light from below for additional glow - more intense
        const rimLight = new THREE.PointLight(0x0044ff, 1.8, 55);
        rimLight.position.set(-5, -15, -10);
        scene.add(rimLight);
        
        // Soft white fill light for general illumination - reduced intensity to emphasize glow
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.25);
        fillLight.position.set(0, 15, 15);
        scene.add(fillLight);
        
        // Position camera with a higher angle view
        camera.position.z = 25;
        camera.position.y = 10; // Add elevation for top-down angle
        camera.lookAt(0, 0, 0); // Ensure camera is looking at the center of the globe
        
        // Load land coordinates (simplified version)
        window.landPoints = [];
        window.landDots = new THREE.Group();
        globeGroup.add(window.landDots);
        
        // Create land dots based on actual land/sea distribution
        function createLandPoints() {
            console.time('landPoints');
            
            // Use instance rendering instead of individual meshes for massive performance improvement
            // This allows us to render thousands of dots with minimal performance impact
            
            // Resolution settings - use configurable options
            const dotSize = CONFIG.dotSize; // Use configurable dot size
            
            // Create a single geometry for all dots
            const dotGeometry = new THREE.CircleGeometry(dotSize, CONFIG.dotSegments);
            
            // Create a material for all dots with better visual quality/performance balance
            const dotMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xbbeeff, // Light blue tint that contrasts with darker globe
                side: THREE.DoubleSide, // Make sure circles are visible from both sides
                transparent: true,
                opacity: CONFIG.dotOpacity, // Use the configurable opacity
                depthTest: true, // Enable depth testing for proper occlusion
                depthWrite: true, // Ensure dots write to depth buffer
                blending: THREE.NormalBlending // Use normal blending for better performance
            });

            // High-resolution world map bitmap (simplified representation of Earth's land masses)
            // Each row represents a latitude band from 90°N to 90°S
            // Each character in a row represents a longitude band from 180°W to 180°E
            // 1 = land, 0 = water
            const worldMap = ["000000000000000000000000000000000000000000000000000000001111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000000000000111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000000000001111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000000000001111111110111111111111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000000000000111111000011111111111111111111110000000000000000000000000000000000000000000000000000011111111100000000000000000000000000000000000000000000000000", "000000000000000000000000000000001110000000000000000000000000000011111111111111111110000000000000000000000000000000000000000000000000111111111111100000000000000000000000000000000000000000000000000", "000000000000000000000000000000111111101110000000111111100000000011111111111111110000000000000000000000000000000000000000000011100111111111111111111100111100000011000000000000000000000000000000000", "000000000000001111100000000000111111111110011100111111111000000001111111111111110000000000000000000000000000000000000000000011111111111111111111111111111111110011111111110000000000000000000000000", "000000001111111111110000111110000111111110011100110111111000000001111111111111110000000000000000000001111111110000000000110011111111111111111111111111111111111111111111111111110011100000000000000", "000001111111111111111111111111111111111100111111110001111100001111111111111111100000000000000000000111111111111110001111111101111111111111111111111111111111111111111111111111111111111111000000000", "000111111111111111111111111111111111111111111111100001111100000111111111100000000000000000000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000", "001111111111111111111111111111111111111111111110000111111100000111111111000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000", "001111111111111111111111111111111111111111111000000111111000000111111000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111000", "111111111111111111111111111111111111111111110000010011110000000111111000000000000000000000000001111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000", "111111111111111111111111111111111111111110000000111100110000000011110000000000000000000000000011111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000", "111111111111111111111111111111111111111000000011111100110000000001100000000000000000000000000011111111011111111111111111111111111111111111111111111111111111111111111111111111111100011111100000000", "111110100000111111111111111111111111110000000011111111110000000000000000000000000000000000000011111111001111111111111111111111111111111111111111111111111111111111111111111111111100111101000000000", "011000000000011111111111111111111111111000000011111111110000000000000000000000000000000000000000011110111111111111111111111111111111111111111111111111111111111111111111111000000000111110000000000", "000000000000001111111111111111111111111111100011111111110000000000000000000000000000000000000000011110111111111111111111111111111111111111111111111111111111111111111111111000000000111111000000000", "000000000000011111111111111111111111111111111111111111111100000000000000000000000000000000000001111011111111111111111111111111111111111111111111111111111111111111111111111000000000011111000000000", "000000000000011111111111111111111111111111011111111111111100000000000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111100000001111000000000", "000000000000011111111111111111111111111111111111111111111100000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000111000000000", "000000000000011111111111111111111111111111111111111111111000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000011000000000", "000000000000001111111111111111111111111111111111111111000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000000000000", "000000000000011111111111111111111111111111111111111100000000000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000000000000", "000000000000011111111111111111111111111111111111111111000000000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000000000000", "000000000000111111111111111111111111111111111111111111000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000100000000000000", "000000000001111111111111111111111111111111111111111100000000000000000000000000000000011001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000110000000000000", "000000000001111111111111111111111111111111111110110000000000000000000000000000000000111111111110111111111111111111111111111111111111111111111111111111111111111111111111111111110000111000000000000", "000000000011111111111111111111111111111111111100000000000000000000000000000000000000111111111000011111111111111111111111111111111111111111111111111111111111111111111111111111000000111000000000000", "000000000111111111111111111111111111111111111000000000000000000000000000000000000000111111110000000111111111111111111111111111111111111111111111111111111111111111111111111111000000110000000000000", "000000000111111111111111111111111111111111100000000000000000000000000000000000000000111111100000000111111101111111111111111111111111111111111111111111111111111111111111011111000000110000000000000", "000000000111111111111111111111111111111111000000000000000000000000000000000000000000111111100000001110011101111111111111111111111111111111111111111111111111111111111110000111100010110000000000000", "000000000111111111111111111111111111111110000000000000000000000000000000000000000000111110011111111100011101111111111111111111111111111111111111111111111111111111111111110111110111111000000000000", "000000000111111111111111111111111111111110000000000000000000000000000000000000000000001111111111110000000000011011111111111111111111111111111111111111111111111111111111110011110111111000000000000", "000000000011111111111111111111111111111000000000000000000000000000000000000000000000011111111111100000000000000001111111111111111111111111111111111111111111111111111111110011100111110000000000000", "000000000001111111111111111111111111110000000000000000000000000000000000000000000001111111111111111000011000000001111111111111111111111111111111111111111111111111111111110000000000000000000000000", "000000000000111111111111111111111111100000000000000000000000000000000000000000000001111111111111111110011111110011111111111111111111111111111111111111111111111111111111111100000000000000000000000", "000000000001111111111111111111111111000000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000", "000000000000111111111111111111100111000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000", "000000000000111111111111110000000111000000000000000000000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000", "000000000000111111111111000000000111000000000000000000000000000000000000000000001111111111111111111111111111111110111111111101111111111111111111111111111111111111111111111100000000000000000000000", "000000000000011111111111000000000011000000000000000000000000000000000000000000011111111111111111111111111111111111111111111100011111111111111111111111111111111111111111111100000000000000000000000", "000000000000011011111111000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111011111111111111000001111111111111111111111111111111111111000000000000000000000000", "000000000000000011111111000000000000000000000000000000000000000000000000000000111111111111111111111111111111111111111111111111111110000011111111111111111111111111111111110000000000000000000000000", "000000000000000011111110000111000000000000000000000000000000000000000000000000111111111111111111111111111111111111101111111111111110000001111111111111111111111111111111000000000000000000000000000", "000000000000000001111111000111000000000000000000000000000000000000000000000000111111111111111111111111111111111111111111111111111110000000111111111111000111111111100110000000000000000000000000000", "000000000000000001111111101111000000000000000000000000000000000000000000000000111111111111111111111111111111111111110111111111111100000000001111111110000111111111101110000000000000000000000000000", "000000000000000001111111111111000000000000000000000000000000000000000000000000111111111111111111111111111111111111111011111111111000000000001111111100000011111111111100000000000000000000000000000", "000000000000000000011111111111100000000000000000000000000000000000000000000000111111111111111111111111111111111111111011111111110000000000001111111000000001111111111000000000000000000000000000000", "000000000000000000000111111111110000000000000000000000000000000000000000000001111111111111111111111111111111111111111101111111100000000000001111110000000001111111111000000000000000000000000000000", "000000000000000000000000011111110000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111110000000000000000111110000000000011111111100000000000000000000000000000", "000000000000000000000000000111110000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111000000000000000000111110000000000011111111100000000000000000000000000000", "000000000000000000000000000001110000001111000000000000000000000000000000000001111111111111111111111111111111111111111111000011000000000000000111110000000000011111111100000000000000000000000000000", "000000000000000000000000000001110000111111111100000000000000000000000000000000011111111111111111111111111111111111111111111111000000000000000011110000000000011111111100000000000000000000000000000", "000000000000000000000000000001111001111111111110000000000000000000000000000000011111111111111111111111111111111111111111111111000000000000000011110000000000011101111000000000000000000000000000000", "000000000000000000000000000000011101111111111111100000000000000000000000000000001111111111111111111111111111111111111111111110000000000000000001100000000000001100100000000000000000000000000000000", "000000000000000000000000000000000101111111111111110000000000000000000000000000000111111111111111111111111111111111111111111110000000000000000000000000000000000000000000001100000000000000000000000", "000000000000000000000000000000000001111111111111111110000000000000000000000000000111111111111111111111111111111111111111111100000000000000000000000000000000110000000000001110000000000000000000000", "000000000000000000000000000000000001111111111111111111000000000000000000000000000001111100000111111111111111111111111111111000000000000000000000000000000000111000000000111110000000000000000000000", "000000000000000000000000000000000011111111111111111111100000000000000000000000000000000000000000111111111111111111111111111000000000000000000000000000000000011100000001111110000000000000000000000", "000000000000000000000000000000000011111111111111111111100000000000000000000000000000000000000000111111111111111111111111110000000000000000000000000000000000011110000011111110000000000000000000000", "000000000000000000000000000000000111111111111111111111100000000000000000000000000000000000000000111111111111111111111111100000000000000000000000000000000000001111000111111110000000000000000000000", "000000000000000000000000000000001111111111111111111111111000000000000000000000000000000000000001111111111111111111111111000000000000000000000000000000000000000111100111111100000000011100000000000", "000000000000000000000000000000001111111111111111111111111111000000000000000000000000000000000001111111111111111111111111000000000000000000000000000000000000000111100011111100000000011101100000000", "000000000000000000000000000000000111111111111111111111111111111000000000000000000000000000000000111111111111111111111110000000000000000000000000000000000000000011110011111000000000001111111100000", "000000000000000000000000000000001111111111111111111111111111111110000000000000000000000000000000011111111111111111111100000000000000000000000000000000000000000011110000000000000000001111111111000", "000000000000000000000000000000001111111111111111111111111111111111000000000000000000000000000000011111111111111111111000000000000000000000000000000000000000000001110000000000000000000001111111100", "000000000000000000000000000000000111111111111111111111111111111111000000000000000000000000000000001111111111111111111100000000000000000000000000000000000000000000110000000000000000000000111111100", "000000000000000000000000000000000011111111111111111111111111111111000000000000000000000000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000111111110", "000000000000000000000000000000000011111111111111111111111111111110000000000000000000000000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000011101111", "000000000000000000000000000000000001111111111111111111111111111100000000000000000000000000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000111", "000000000000000000000000000000000001111111111111111111111111111100000000000000000000000000000000000111111111111111111100000000000000000000000000000000000000000000000000000000000000011110001100001", "000000000000000000000000000000000001111111111111111111111111111100000000000000000000000000000000001111111111111111111100000110000000000000000000000000000000000000000000000000000000111110001100000", "000000000000000000000000000000000000111111111111111111111111111000000000000000000000000000000000001111111111111111111100001110000000000000000000000000000000000000000000000000001111111100011100000", "000000000000000000000000000000000000011111111111111111111111111000000000000000000000000000000000011111111111111111111100111110000000000000000000000000000000000000000000000000011111111110011110000", "000000000000000000000000000000000000001111111111111111111111111000000000000000000000000000000000011111111111111111111000111110000000000000000000000000000000000000000000000000111111111111111110000", "000000000000000000000000000000000000000011111111111111111111111000000000000000000000000000000000011111111111111111110000111110000000000000000000000000000000000000000000000001111111111111111110000", "000000000000000000000000000000000000000001111111111111111111111000000000000000000000000000000000001111111111111111100000111100000000000000000000000000000000000000000000000011111111111111111111000", "000000000000000000000000000000000000000001111111111111111111110000000000000000000000000000000000001111111111111111100001111100000000000000000000000000000000000000000000011111111111111111111111000", "000000000000000000000000000000000000000001111111111111111111110000000000000000000000000000000000000111111111111111100001111000000000000000000000000000000000000000000001111111111111111111111111100", "000000000000000000000000000000000000000001111111111111111111110000000000000000000000000000000000000111111111111111100001111000000000000000000000000000000000000000000001111111111111111111111111110", "000000000000000000000000000000000000000001111111111111111110000000000000000000000000000000000000000111111111111111100001111000000000000000000000000000000000000000000001111111111111111111111111110", "000000000000000000000000000000000000000001111111111111111000000000000000000000000000000000000000000111111111111111000001111000000000000000000000000000000000000000000001111111111111111111111111110", "000000000000000000000000000000000000000001111111111111111100000000000000000000000000000000000000000011111111111110000000000000000000000000000000000000000000000000000001111111111111111111111111110", "000000000000000000000000000000000000000001111111111111111000000000000000000000000000000000000000000011111111111100000000000000000000000000000000000000000000000000000011111111111111111111111111110", "000000000000000000000000000000000000000001111111111111111000000000000000000000000000000000000000000011111111111100000000000000000000000000000000000000000000000000000011111111111111111111111111110", "000000000000000000000000000000000000000001111111111111110000000000000000000000000000000000000000000001111111111000000000000000000000000000000000000000000000000000000001111111111111111111111111110", "000000000000000000000000000000000000000001111111111111110000000000000000000000000000000000000000000001111111110000000000000000000000000000000000000000000000000000000001111111111111111111111111100", "000000000000000000000000000000000000000000111111111111100000000000000000000000000000000000000000000000111111100000000000000000000000000000000000000000000000000000000011111111100011111111111111000", "000000000000000000000000000000000000000000111111111111100000000000000000000000000000000000000000000000111110000000000000000000000000000000000000000000000000000000000011111100000001111111111110000", "000000000000000000000000000000000000000000111111111110000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000011000000000000011111111100000", "000000000000000000000000000000000000000000111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111000000", "000000000000000000000000000000000000000000111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111110000000", "000000000000000000000000000000000000000000111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001111000000000", "000000000000000000000000000000000000000000111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000011111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000011111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000001111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000011111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000011111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000001111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000001111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000000111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000000011110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"];
            
            // Helper function to check if a point is on land
            function isLand(lat, lon) {
                // Convert to map indices - the worldMap has lat from 90°N to 90°S (top to bottom)
                // Note: We use worldMap.length - 1 - latIndex to flip the y-axis since worldMap is stored top to bottom
                const latIndex = Math.min(worldMap.length - 1, Math.max(0, Math.floor((90 - lat) * worldMap.length / 180)));
                const lonIndex = Math.min(worldMap[0].length - 1, Math.max(0, Math.floor((lon + 180) * worldMap[0].length / 360)));
                
                return worldMap[latIndex][lonIndex] === '1';
            }
            
            // Create points in a more even distribution using the Fibonacci lattice
            // This avoids concentration at the poles
            const numPoints = CONFIG.numPoints; // Use configurable number of points
            
            // First pass: count how many land points we'll have
            const landPositions = [];
            const landNormals = [];
            const landData = [];
            
            for (let i = 0; i < numPoints; i++) {
                // Fibonacci lattice formula for even distribution on a sphere
                const phi = Math.acos(1 - 2 * (i + 0.5) / numPoints);
                const theta = Math.PI * (1 + Math.sqrt(5)) * (i + 0.5);
                
                // Convert to lat/lon
                const lat = 90 - (phi * 180 / Math.PI);
                const lon = (theta * 180 / Math.PI) % 360 - 180;
                
                // Only place a dot if the map indicates land
                if (isLand(lat, lon)) {
                    // Convert lat/lon to 3D coordinates
                    // Note the negative sign on x to correctly orient the globe
                    const phi = (90 - lat) * Math.PI / 180;
                    const theta = (lon + 180) * Math.PI / 180;
                    
                    // Lift the points slightly off the globe's surface for better visibility
                    const pointRadius = radius * 1.005; // 0.5% larger than globe radius
                    const x = -pointRadius * Math.sin(phi) * Math.cos(theta);
                    const y = pointRadius * Math.cos(phi);
                    const z = pointRadius * Math.sin(phi) * Math.sin(theta);
                    
                    // Store position and normal for instancing
                    landPositions.push(x, y, z);
                    
                    // Normal is just the normalized position for a sphere
                    const normal = new THREE.Vector3(x, y, z).normalize();
                    landNormals.push(normal.x, normal.y, normal.z);
                    
                    // Store additional data for hover effects
                    landData.push({
                        originalPosition: new THREE.Vector3(x, y, z),
                        hovering: false,
                        phi: phi,
                        theta: theta
                    });
                }
            }
            
            // Now we know how many dots we need
            const instanceCount = landPositions.length / 3;
            console.log(`Creating ${instanceCount} land dots`);
            
            if (instanceCount > 0) {
                // Create instanced mesh for much better performance
                const instancedDots = new THREE.InstancedMesh(dotGeometry, dotMaterial, instanceCount);
                instancedDots.count = instanceCount;
                
                // Create matrix and quaternion for positioning instances
                const matrix = new THREE.Matrix4();
                const quaternion = new THREE.Quaternion();
                const position = new THREE.Vector3();
                const scale = new THREE.Vector3(1, 1, 1);
                
                // Set instance matrices
                for (let i = 0; i < instanceCount; i++) {
                    // Get position
                    position.set(
                        landPositions[i * 3],
                        landPositions[i * 3 + 1],
                        landPositions[i * 3 + 2]
                    );
                    
                    // Calculate rotation to face outward
                    const normal = new THREE.Vector3(
                        landNormals[i * 3],
                        landNormals[i * 3 + 1],
                        landNormals[i * 3 + 2]
                    );
                    
                    // Use lookAt to orient the dot correctly
                    const lookAt = new THREE.Vector3().copy(position).add(normal);
                    const up = new THREE.Vector3(0, 1, 0);
                    const rotationMatrix = new THREE.Matrix4().lookAt(position, lookAt, up);
                    quaternion.setFromRotationMatrix(rotationMatrix);
                    
                    // Create transformation matrix
                    matrix.compose(position, quaternion, scale);
                    instancedDots.setMatrixAt(i, matrix);
                    
                    // Store data for hover (we'll handle this differently now)
                    const dot = {
                        index: i,
                        position: position.clone(),
                        originalPosition: position.clone(),
                        userData: landData[i]
                    };
                    landPoints.push(dot);
                }
                
                // Update the instance matrices
                instancedDots.instanceMatrix.needsUpdate = true;
                
                // Add to scene
                landDots.add(instancedDots);
                landDots.userData.instancedDots = instancedDots;
            }
            
            // Store the positions and normals arrays for hover effects
            landDots.userData.positions = landPositions;
            landDots.userData.normals = landNormals;
        }
        
        createLandPoints();
        console.timeEnd('landPoints');
        console.log(`Created ${landPoints.length} land points`);
        
        // Arcs between points
        window.arcs = [];
        // Create a group to hold all arcs for easier manipulation
        window.arcsGroup = new THREE.Group();
        globeGroup.add(window.arcsGroup);
        
        function createArc(startPoint, endPoint) {
            const startPos = startPoint.position.clone();
            const endPos = endPoint.position.clone();
            
            // Calculate a curved path between points
            const midPoint = startPos.clone().add(endPos).multiplyScalar(0.5);
            const distance = startPos.distanceTo(endPos);
            
            // Make the arc height significantly higher for a more dramatic curve
            // Height is increased substantially to create towering arcs
            midPoint.normalize().multiplyScalar(radius + distance * 1.8); // Much higher, more dramatic arcs
            
            // Slightly adjust start and end points to ensure arcs touch the globe
            const adjustStartPos = startPos.clone().normalize().multiplyScalar(radius * 0.997);
            const adjustEndPos = endPos.clone().normalize().multiplyScalar(radius * 0.997);
            
            // Calculate all points for the complete path
            const allPoints = [];
            
            // Create more points at the start and end of the path for smoother animations
            // This creates a denser point distribution at both ends of the arc
            for (let i = 0; i <= CONFIG.arcPointsCount; i++) { // Use configurable point count
                // Apply non-linear distribution to create more points at the beginning and end
                // Use a modified sine curve to create denser sampling at both ends
                let t;
                if (i === 0) {
                    t = 0;
                } else if (i === CONFIG.arcPointsCount) {
                    t = 1;
                } else {
                    // Use an easing function that creates more points at the start and end
                    // This is a sine-based distribution function that clusters points at both ends
                    const normalizedI = i / CONFIG.arcPointsCount;
                    t = (Math.sin((normalizedI - 0.5) * Math.PI) + 1) / 2;
                }
                
                const point = new THREE.Vector3();
                
                if (i === 0) {
                    // Use adjusted start position for first point to touch globe
                    point.copy(adjustStartPos);
                } else if (i === CONFIG.arcPointsCount) {
                    // Use adjusted end position for last point to touch globe
                    point.copy(adjustEndPos);
                } else {
                    // Use cubic Bezier curve for smoother arcs
                    // Create two control points for better rounding
                    // Adjust control points to create smoother, more parabolic arcs
                    // First control point closer to start, second closer to end
                    const cp1 = new THREE.Vector3().lerpVectors(adjustStartPos, midPoint, 0.25);
                    const cp2 = new THREE.Vector3().lerpVectors(midPoint, adjustEndPos, 0.75);
                    
                    // Cubic Bezier formula
                    const u = 1 - t;
                    const tt = t * t;
                    const uu = u * u;
                    const uuu = uu * u;
                    const ttt = tt * t;
                    
                    point.x = uuu * adjustStartPos.x + 3 * uu * t * cp1.x + 3 * u * tt * cp2.x + ttt * adjustEndPos.x;
                    point.y = uuu * adjustStartPos.y + 3 * uu * t * cp1.y + 3 * u * tt * cp2.y + ttt * adjustEndPos.y;
                    point.z = uuu * adjustStartPos.z + 3 * uu * t * cp1.z + 3 * u * tt * cp2.z + ttt * adjustEndPos.z;
                }
                
                allPoints.push(point);
            }
            
            // For initial creation, use multiple points to make a smoother initial tube
            // Using more points at the start creates a smoother initial appearance
            const initialPoints = [allPoints[0], allPoints[1], allPoints[2], allPoints[3]];
            const tubePath = new THREE.CatmullRomCurve3(initialPoints);
            tubePath.tension = 0.5; // Set tension for smoother curve
            
            // Create a tube geometry with smoother settings
            const tubeGeometry = new THREE.TubeGeometry(
                tubePath, 
                3, // Use more segments for smoother initial appearance
                CONFIG.arcThickness, 
                CONFIG.arcRadialSegments, 
                false
            ); // Use configurable settings
            
            // Randomly select two colors from the color palette for the gradient
            const colorIndex1 = Math.floor(Math.random() * CONFIG.arcColors.length);
            let colorIndex2 = Math.floor(Math.random() * CONFIG.arcColors.length);
            // Make sure we pick two different colors
            while (colorIndex2 === colorIndex1) {
                colorIndex2 = Math.floor(Math.random() * CONFIG.arcColors.length);
            }
            
            const startColor = new THREE.Color(CONFIG.arcColors[colorIndex1]);
            const endColor = new THREE.Color(CONFIG.arcColors[colorIndex2]);
            
            // Use a gradient texture for the arc color with enhanced transition
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 1;
            const context = canvas.getContext('2d');
            
            // Create a linear gradient with smoother transition
            const gradient = context.createLinearGradient(0, 0, canvas.width, 0);
            
            // Improve gradient with more color stops for richer transition
            // Start with the pure start color
            gradient.addColorStop(0, '#' + startColor.getHexString());
            
            // Add a 25% blend for smoother transition
            const quarterBlend = new THREE.Color().lerpColors(startColor, endColor, 0.25);
            gradient.addColorStop(0.3, '#' + quarterBlend.getHexString());
            
            // Add a 75% blend for smoother transition
            const threeQuarterBlend = new THREE.Color().lerpColors(startColor, endColor, 0.75);
            gradient.addColorStop(0.7, '#' + threeQuarterBlend.getHexString());
            
            // End with the pure end color
            gradient.addColorStop(1, '#' + endColor.getHexString());
            
            // Fill the canvas with the enhanced gradient
            context.fillStyle = gradient;
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Create a texture from the canvas
            const gradientTexture = new THREE.CanvasTexture(canvas);
            gradientTexture.needsUpdate = true;
            
            // Create the tube material with the gradient texture and improved settings
            const tubeMaterial = new THREE.MeshBasicMaterial({
                opacity: 0.9, // Increased opacity for better contrast against darker globe
                transparent: true,
                depthWrite: false, // Disable depth writing for better blending
                blending: THREE.AdditiveBlending, // Use additive blending for a glowing effect
                toneMapped: false, // Disable tone mapping for brighter appearance
                map: gradientTexture // Apply the gradient texture
            });
            
            // Create the mesh and add to globe group
            const arc = new THREE.Mesh(tubeGeometry, tubeMaterial);
            globeGroup.add(arc);
            
            return {
                arc: arc,
                tubeMaterial: tubeMaterial,
                allPoints: allPoints,
                progress: 0,
                growDuration: CONFIG.arcGrowDuration + Math.random() * 0.4, // Configurable growth time
                maxLife: CONFIG.arcRetreatDuration + Math.random() * 0.8, // Configurable retreat time
                age: 0,
                destinationPoint: endPos.clone(), // Store the destination point for impact effect
                impactCreated: false, // Flag to track if impact effect has been created
                startColor: startColor, // Store the start color for reference
                endColor: endColor // Store the end color for impact effect
            };
        }
        
        // Create explosion effect at arc destinations
        function createImpactEffect(position, color) {
            // Use the provided color or default to cyan if no color is passed
            const impactColor = color || new THREE.Color(0x88eeff);
            
            // Create a ring (bordered circle) that will expand outward
            const ringGeometry = new THREE.RingGeometry(
                CONFIG.bullseyeSize * 0.67, // Inner radius - creates the border effect
                CONFIG.bullseyeSize,  // Outer radius
                24     // More segments for a smoother ring
            );
            const circleMaterial = new THREE.MeshBasicMaterial({
                color: impactColor, // Use the arc's end color
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.95, // Slightly higher opacity for better visibility of the thin ring
                depthWrite: false, // Disable depth writing for better blending
                blending: THREE.AdditiveBlending, // Use additive blending for glow effect
                toneMapped: false // Disable tone mapping for brighter appearance
            });
            
            const circle = new THREE.Mesh(ringGeometry, circleMaterial);
            
            // Position at the destination point
            circle.position.copy(position);
            
            // Make circle tangent to the globe surface
            circle.lookAt(new THREE.Vector3(0, 0, 0));
            
            // Add to globe group
            globeGroup.add(circle);
            
            // Create a secondary outer ring with a lighter version of the impact color
            const outerRingGeometry = new THREE.RingGeometry(
                CONFIG.bullseyeSize * 0.67, // Inner radius
                CONFIG.bullseyeSize, // Outer radius - creates a larger border
                24     // More segments for a smoother ring
            );
            
            // Create a lighter but still colorful version of the impact color for the outer circle
            const lightenedColor = impactColor.clone().lerp(new THREE.Color(0xffffff), 0.4);
            
            const outerCircleMaterial = new THREE.MeshBasicMaterial({
                color: lightenedColor, // Lighter version of impact color
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.75, // Slightly increased opacity for better visibility of the thin ring
                depthWrite: false, // Disable depth writing for better blending
                blending: THREE.AdditiveBlending, // Use additive blending for glow effect
                toneMapped: false // Disable tone mapping for brighter appearance
            });
            
            const outerCircle = new THREE.Mesh(outerRingGeometry, outerCircleMaterial);
            
            // Position at the destination point but slightly behind the inner circle
            outerCircle.position.copy(position);
            
            // Move it slightly toward the globe to avoid z-fighting
            const directionToCenter = new THREE.Vector3(0, 0, 0).sub(position).normalize();
            outerCircle.position.add(directionToCenter.multiplyScalar(0.01));
            
            // Make circle tangent to the globe surface
            outerCircle.lookAt(new THREE.Vector3(0, 0, 0));
            
            // Add to globe group
            globeGroup.add(outerCircle);
            
            // Create a permanent bullseye target at the landing point
            // Center filled circle
            const centerDotGeometry = new THREE.CircleGeometry(CONFIG.bullseyeSize, 24);
            const centerDotMaterial = new THREE.MeshBasicMaterial({
                color: impactColor,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.85,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                toneMapped: false
            });
            
            const centerDot = new THREE.Mesh(centerDotGeometry, centerDotMaterial);
            centerDot.position.copy(position);
            
            // Move it slightly away from globe to avoid z-fighting
            const directionFromCenter = position.clone().normalize();
            centerDot.position.add(directionFromCenter.multiplyScalar(0.008));
            
            // Make it tangent to the globe surface
            centerDot.lookAt(new THREE.Vector3(0, 0, 0));
            
            // Add to globe group
            globeGroup.add(centerDot);
            
            // Middle ring of the bullseye
            const middleRingGeometry = new THREE.RingGeometry(CONFIG.bullseyeSize * 1.22, CONFIG.bullseyeRingSize, 24);
            const middleRingMaterial = new THREE.MeshBasicMaterial({
                color: lightenedColor,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.75,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                toneMapped: false
            });
            
            const middleRing = new THREE.Mesh(middleRingGeometry, middleRingMaterial);
            middleRing.position.copy(centerDot.position);
            middleRing.lookAt(new THREE.Vector3(0, 0, 0));
            
            // Add to globe group
            globeGroup.add(middleRing);
            
            // Return object with properties for animation
            return {
                circle: circle,                    // Expanding ring 1
                circleMaterial: circleMaterial,
                outerCircle: outerCircle,          // Expanding ring 2
                outerCircleMaterial: outerCircleMaterial,
                centerDot: centerDot,              // Permanent bullseye center
                centerDotMaterial: centerDotMaterial,
                middleRing: middleRing,            // Permanent bullseye outer ring
                middleRingMaterial: middleRingMaterial,
                age: 0,
                maxLife: 0.5 + Math.random() * 0.3,  // Shorter lifespan for expanding rings (0.5-0.8 seconds)
                startTime: performance.now() / 1000,  // Current time in seconds
                arcLifetime: 0, // Will be set by the arc
                position: position.clone(), // Store position for reference
                linkedToArc: false // Flag to indicate if this effect is linked to an arc
            };
        }
        
        // Store active impact effects
        const impactEffects = [];
        
        // Randomly create arcs
        function addRandomArc() {
            if (landPoints.length < 2) return;
            
            const startIndex = Math.floor(Math.random() * landPoints.length);
            const startPoint = landPoints[startIndex];
            
            // Find suitable endpoints for the arc
            const candidatePoints = [];
            
            // Collect all points within suitable distance range
            // We want a good mix of short, medium and long paths
            for (let i = 0; i < landPoints.length; i++) {
                if (i !== startIndex) {
                    const dist = startPoint.position.distanceTo(landPoints[i].position);
                    // Wider distance range to allow for more varied arcs
                    if (dist > radius * 0.25 && dist < radius * 1.6) {
                        // Calculate a score that prefers points farther away from existing arcs
                        // This prevents clustering of arcs in the same area
                        let proximityScore = 1.0;
                        
                        // Check proximity to existing arc endpoints
                        for (const arc of arcs) {
                            const distToArc = landPoints[i].position.distanceTo(arc.destinationPoint);
                            if (distToArc < radius * 0.3) {
                                // Reduce score for points close to existing arcs
                                proximityScore *= 0.7;
                            }
                        }
                        
                        candidatePoints.push({
                            index: i,
                            distance: dist,
                            score: proximityScore
                        });
                    }
                }
            }
            
            // Select endpoint based on both distance and distribution
            let endPointIndex = -1;
            if (candidatePoints.length > 0) {
                // Sort by a combination of distance and proximity score
                // This creates more evenly distributed arcs around the globe
                candidatePoints.sort((a, b) => {
                    // Use normalized distance (0-1 range) * proximity score
                    const aScore = (a.distance / (radius * 1.6)) * a.score;
                    const bScore = (b.distance / (radius * 1.6)) * b.score;
                    // Randomize slightly to prevent predictable patterns
                    return (aScore + Math.random() * 0.1) - (bScore + Math.random() * 0.1);
                });
                
                // Take top 40% for more varied selection
                const topCount = Math.max(1, Math.floor(candidatePoints.length * 0.4));
                const randomIndex = Math.floor(Math.random() * topCount);
                endPointIndex = candidatePoints[randomIndex].index;
            }
            
            if (endPointIndex !== -1) {
                const endPoint = landPoints[endPointIndex];
                const arc = createArc(startPoint, endPoint);
                arcs.push(arc);
            }
        }
        
        // Raycaster for hover detection
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Variables for mouse rotation
        const mouseRotationSpeed = 0.01; // Keep this separate from auto-rotation
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let globeRotation = { x: 0, y: 0 };
        
        // Handle mouse movement
        function onMouseMove(event) {
            // Update mouse position for raycaster (hover effects)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Handle rotation when dragging
            if (isDragging) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;
                
                globeRotation.y += deltaX * mouseRotationSpeed;
                globeRotation.x += deltaY * mouseRotationSpeed;
                
                // Limit vertical rotation to prevent flipping
                globeRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, globeRotation.x));
                
                // Apply rotation to the entire globe group
                globeGroup.rotation.y = globeRotation.y;
                globeGroup.rotation.x = globeRotation.x;
            }
            
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }
        
        // Handle mouse down - start dragging
        function onMouseDown(event) {
            // Only drag with left mouse button
            if (event.button === 0) {
                isDragging = true;
                previousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
                // Change cursor
                document.body.style.cursor = 'grabbing';
            }
        }
        
        // Handle mouse up - stop dragging
        function onMouseUp() {
            isDragging = false;
            // Reset cursor
            document.body.style.cursor = 'auto';
        }
        
        // Add event listeners
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mouseup', onMouseUp);
        window.addEventListener('mouseleave', onMouseUp);
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        window.addEventListener('resize', onWindowResize);
        
        // Animation loop
        let lastArcTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);
            
            // Convert time to seconds
            const seconds = time / 1000;
            
            // Only auto-rotate if not being dragged - slower rotation for performance
            if (!isDragging) {
                // Use frame skipping for better performance if configured
                if (Math.floor(seconds * 30) % (CONFIG.skipFrames + 1) === 0) {
                    globeRotation.y += CONFIG.rotationSpeed;
                    globeGroup.rotation.y = globeRotation.y;
                }
            }
            
            // Atmospheric glow is now handled by inner glow sphere and lighting
            
            // Enhanced pulsing to the lights for dramatic glow effect
            // Optimize light updates by using a longer interval for subtle effects
            // This significantly reduces performance impact of light calculations
            if (Math.floor(seconds * 10) % 4 === 0) {
                const elapsedTime = seconds % 10;
                const primaryPulse = Math.sin(elapsedTime * Math.PI / 5) * 0.07 + 1.0;
                const secondaryPulse = Math.sin((elapsedTime + 2.5) * Math.PI / 5) * 0.05 + 1.0; // Out of phase
                
                // Pulse each light with different intensities and phases for more complex effect
                backLight.intensity = 3.5 * primaryPulse;
                rimLight.intensity = 1.8 * secondaryPulse;
                secondBackLight.intensity = 2.2 * secondaryPulse;
                thirdBackLight.intensity = 1.8 * primaryPulse;
                
                // Also pulse the inner glow opacity for enhanced effect
                innerGlowMaterial.opacity = 0.15 * (primaryPulse * 0.8 + 0.6);
                
                // Animate the atmosphere shader for halo effect
                if (globeGroup.userData.atmosphere && globeGroup.userData.atmosphere.material && 
                    globeGroup.userData.atmosphere.material.uniforms) {
                    // Update the time uniform for the shader animation
                    globeGroup.userData.atmosphere.material.uniforms.time.value = seconds;
                    
                    // Pulse the opacity for enhanced breathing effect
                    globeGroup.userData.atmosphere.material.uniforms.opacity.value = 
                        CONFIG.atmosphereOpacity * 1.5 * (primaryPulse * 0.3 + 0.9);
                    
                    // Adjust the power parameter for varying glow sharpness
                    globeGroup.userData.atmosphere.material.uniforms.power.value = 
                        2.0 + secondaryPulse * 0.3;
                    
                    // Slightly vary the glow color for a more dynamic effect
                    const hue = 0.6 + (primaryPulse * 0.02); // Subtle hue shift in blue range
                    const glowColor = new THREE.Color().setHSL(hue, 0.8, 0.6);
                    globeGroup.userData.atmosphere.material.uniforms.glowColor.value.copy(glowColor);
                }
                
                // Animate the dedicated atmosphere lights for stronger effect
                if (globeGroup.userData.atmosphereLight) {
                    // Pulse the main light intensity
                    globeGroup.userData.atmosphereLight.intensity = 
                        CONFIG.atmosphereGlow * 1.5 * (secondaryPulse * 0.5 + 0.8);
                    
                    // Move the light slightly for dynamic shadows
                    const lightAngle = elapsedTime * 0.5;
                    const lightRadius = radius * 0.15; // Increased orbit radius
                    globeGroup.userData.atmosphereLight.position.set(
                        Math.sin(lightAngle) * lightRadius,
                        Math.cos(lightAngle * 0.8) * lightRadius,
                        Math.sin(lightAngle * 1.2) * lightRadius
                    );
                    
                    // Animate the second light with different pattern
                    if (globeGroup.userData.atmosphereLight2) {
                        // Use different pulse pattern for second light
                        const altPulse = Math.sin(elapsedTime * 0.7 + 1.0) * 0.3 + 1.0;
                        globeGroup.userData.atmosphereLight2.intensity = 
                            CONFIG.atmosphereGlow * 0.8 * altPulse;
                        
                        // Move in a different orbital pattern
                        const light2Angle = elapsedTime * 0.3 + Math.PI; // Offset phase
                        const light2Radius = radius * 0.25;
                        globeGroup.userData.atmosphereLight2.position.set(
                            Math.cos(light2Angle * 1.1) * light2Radius,
                            Math.sin(light2Angle * 0.9) * light2Radius * 0.7,
                            Math.sin(light2Angle * 1.3) * light2Radius
                        );
                    }
                }
            }
            
            // Add random arcs more aggressively to ensure continuous flow
            if ((seconds - lastArcTime > CONFIG.arcFrequency + (Math.random() * CONFIG.arcTimingVariation)) || 
                // Force arc creation if we're significantly below the maximum
                (arcs.length < CONFIG.maxConcurrentArcs * 0.7 && seconds - lastArcTime > 0.1)) {
                addRandomArc();
                lastArcTime = seconds;
            }
            
            // Only update arcs and impact effects on appropriate frames based on skipFrames
            // Skip frames based on configuration for better performance
            if (Math.floor(seconds * 30) % (CONFIG.skipFrames + 1) === 0) {
                // Update arcs
                for (let i = arcs.length - 1; i >= 0; i--) {
                    const arc = arcs[i];
                    arc.age += 0.02; // Normal increment for smooth animation
                
                // During growth phase - extend the arc
                if (arc.age < arc.growDuration) {
                    // Calculate how far along the growth we are (0 to 1) with easing function
                    let growthProgress = arc.age / arc.growDuration;
                    
                    // Apply easing function for smoother growth (easeInOutQuad)
                    if (growthProgress < 0.5) {
                        growthProgress = 2 * growthProgress * growthProgress;
                    } else {
                        growthProgress = -1 + (4 - 2 * growthProgress) * growthProgress;
                    }
                    
                    // If we've reached 90% of the growth and haven't created an impact effect yet
                    if (growthProgress >= 0.9 && !arc.impactCreated) {
                        // Create impact effect at destination with the arc's end color
                        const effect = createImpactEffect(arc.destinationPoint, arc.endColor);
                        // Link the effect to this arc's lifetime
                        effect.arcLifetime = arc.maxLife;
                        effect.linkedToArc = true; // Mark this effect as linked to an arc
                        effect.parentArc = arc; // Two-way reference to help with cleanup
                        impactEffects.push(effect);
                        arc.impactCreated = true; // Mark that we've created the impact
                        arc.impactEffect = effect; // Store reference to the effect
                        
                        // Add a pulse animation to the bullseye for emphasis
                        setTimeout(() => {
                            if (effect.centerDot && effect.middleRing) {
                                const originalScale = effect.centerDot.scale.clone();
                                let time = 0;
                                const duration = 0.5; // Duration in seconds
                                const pulse = () => {
                                    time += 0.016; // ~60fps
                                    if (time < duration) {
                                        const progress = time / duration;
                                        const scale = 1 + Math.sin(progress * Math.PI) * 0.5;
                                        effect.centerDot.scale.set(scale, scale, 1);
                                        effect.middleRing.scale.set(scale, scale, 1);
                                        requestAnimationFrame(pulse);
                                    } else {
                                        effect.centerDot.scale.copy(originalScale);
                                        effect.middleRing.scale.copy(originalScale);
                                    }
                                };
                                pulse();
                            }
                        }, 50); // Small delay to ensure elements are added to scene
                    }
                    
                    // Calculate how many points should be visible
                    const pointCount = Math.max(2, Math.floor(growthProgress * arc.allPoints.length));
                    
                    // Get current visible points
                    const currentPoints = arc.allPoints.slice(0, pointCount);
                    
                    try {
                        // Create new tube geometry with current points
                        const tubePath = new THREE.CatmullRomCurve3(currentPoints);
                        
                        // Apply lower tension for smoother, rounder curves during growth
                        tubePath.tension = 0.4;
                        
                        // Calculate dynamic segments for better quality during growth
                        const dynamicSegments = Math.max(
                            5, 
                            Math.min(
                                CONFIG.arcTubeSegments, 
                                Math.ceil(pointCount * 0.8) // Scale segments with curve length for smoother curves
                            )
                        );
                        
                        const newTubeGeometry = new THREE.TubeGeometry(
                            tubePath, 
                            dynamicSegments, // More segments for smoother appearance
                            CONFIG.arcThickness, // Configurable thickness
                            CONFIG.arcRadialSegments, 
                            false
                        );
                        
                        // Remove old mesh from globe group
                        globeGroup.remove(arc.arc);
                        
                        // Dispose old geometry to prevent memory leaks
                        if (arc.arc.geometry) {
                            arc.arc.geometry.dispose();
                        }
                        
                        // Replace with new geometry
                        arc.arc.geometry = newTubeGeometry;
                        
                        // Add back to globe group
                        globeGroup.add(arc.arc);
                    } catch(e) {
                        // If there's an error, just skip this frame
                        console.log("Arc animation error", e);
                    }
                    
                    arc.tubeMaterial.opacity = 0.7; // Full opacity during growth
                }
                // Retreat arcs after growing - line leaves from origin point
                else if (arc.age > arc.growDuration) {
                    // Calculate retreat progress (0 to 1) with improved easing
                    let retreatProgress = Math.min(1, (arc.age - arc.growDuration) / arc.maxLife);
                    
                    // Apply custom easing function for smoother retreat
                    // This creates a slow start, fast middle, and slow end
                    retreatProgress = Math.pow(retreatProgress, 2) * (3 - 2 * retreatProgress);
                    
                    // Apply additional easing at the beginning for an even smoother start
                    if (retreatProgress < 0.2) {
                        retreatProgress = retreatProgress * retreatProgress * 5;
                    }
                    
                    // Calculate how many points should be visible as the line retreats
                    // Use non-linear mapping for smoother retreat
                    const startIndex = Math.floor(retreatProgress * arc.allPoints.length);
                    const pointCount = arc.allPoints.length - startIndex;
                    
                    // Skip if too few points remain
                    if (pointCount < 2) {
                        // Skip rendering when almost gone
                        arc.tubeMaterial.opacity = 0;
                        continue;
                    }
                    
                    // Get current visible points - shifting starting position as line retreats
                    const currentPoints = arc.allPoints.slice(startIndex);
                    
                    try {
                        // Create new tube geometry with retreating points
                        const tubePath = new THREE.CatmullRomCurve3(currentPoints);
                        
                        // Apply lower tension for smoother, rounder curves during retreat
                        tubePath.tension = 0.4;
                        
                        // Use higher segment count for smoother retreating appearance
                        const dynamicSegments = Math.max(
                            5, 
                            Math.min(
                                CONFIG.arcTubeSegments, 
                                Math.ceil(pointCount * 0.9) // Higher scaling for retreat for smoother curves
                            )
                        );
                        
                        const newTubeGeometry = new THREE.TubeGeometry(
                            tubePath, 
                            dynamicSegments,
                            // Gradually thin the arc as it retreats for a more elegant disappearance
                            CONFIG.arcThickness * (1 - (retreatProgress * 0.3)), // More pronounced thinning during retreat
                            CONFIG.arcRadialSegments,
                            false
                        );
                        
                        // Remove old mesh from globe group
                        globeGroup.remove(arc.arc);
                        
                        // Dispose old geometry to prevent memory leaks
                        if (arc.arc.geometry) {
                            arc.arc.geometry.dispose();
                        }
                        
                        // Replace with new geometry
                        arc.arc.geometry = newTubeGeometry;
                        
                        // Add back to globe group
                        globeGroup.add(arc.arc);
                    } catch(e) {
                        // If there's an error, just skip this frame
                        console.log("Arc retreat animation error", e);
                    }
                }
                
                // Remove old arcs
                if (arc.age >= arc.growDuration + arc.maxLife) {
                    globeGroup.remove(arc.arc);
                    arc.arc.geometry.dispose();
                    
                    // If this arc has a linked impact effect, start fading out the bullseye elements
                    if (arc.impactEffect) {
                        console.log("Starting fade out for bullseye");
                        
                        // Mark the effect as fading instead of removing immediately
                        arc.impactEffect.isFadingOut = true;
                        arc.impactEffect.fadeStartTime = performance.now() / 1000;
                        arc.impactEffect.fadeDuration = 1.0; // 1 second fade-out duration
                        
                        // Keep the reference to the effect but remove the reference from the arc
                        // so we don't double-process it
                        arc.impactEffect = null;
                    }
                    
                    arcs.splice(i, 1);
                }
            }
            
            // Update impact effects
            for (let i = impactEffects.length - 1; i >= 0; i--) {
                const effect = impactEffects[i];
                
                // Handle fading out bullseye effects
                if (effect.isFadingOut) {
                    const currentTime = performance.now() / 1000;
                    const fadeElapsed = currentTime - effect.fadeStartTime;
                    const fadeProgress = Math.min(1, fadeElapsed / effect.fadeDuration);
                    
                    // Apply fade out to bullseye elements
                    if (effect.centerDot && effect.centerDotMaterial) {
                        effect.centerDotMaterial.opacity = Math.max(0, 0.85 * (1 - fadeProgress));
                    }
                    
                    if (effect.middleRing && effect.middleRingMaterial) {
                        effect.middleRingMaterial.opacity = Math.max(0, 0.75 * (1 - fadeProgress));
                    }
                    
                    // If fade completed, remove the elements
                    if (fadeProgress >= 1) {
                        console.log("Fade out complete, removing bullseye elements");
                        
                        // Remove bullseye center dot
                        if (effect.centerDot) {
                            globeGroup.remove(effect.centerDot);
                            effect.centerDotMaterial.dispose();
                            effect.centerDot.geometry.dispose();
                        }
                        
                        // Remove bullseye outer ring
                        if (effect.middleRing) {
                            globeGroup.remove(effect.middleRing);
                            effect.middleRingMaterial.dispose();
                            effect.middleRing.geometry.dispose();
                        }
                        
                        // Remove the effect from the array and continue to next iteration
                        impactEffects.splice(i, 1);
                        continue;
                    }
                    
                    // Continue to next effect since we've handled this one
                    continue;
                }
                
                // Safety check: if this effect is linked to an arc that no longer exists
                // or is about to be removed, start fading it out
                if (effect.linkedToArc && effect.parentArc) {
                    const arcIndex = arcs.indexOf(effect.parentArc);
                    if (arcIndex === -1 || effect.parentArc.age >= effect.parentArc.growDuration + effect.parentArc.maxLife) {
                        console.log("Starting fade out for orphaned bullseye effect");
                        
                        // Mark the effect as fading instead of removing immediately
                        effect.isFadingOut = true;
                        effect.fadeStartTime = performance.now() / 1000;
                        effect.fadeDuration = 1.0; // 1 second fade-out duration
                        effect.parentArc = null; // Clear the parent reference
                        
                        // Continue to next iteration
                        continue;
                    }
                }
                
                effect.age += 0.02; // Match arc update rate
                
                if (effect.age < effect.maxLife) {
                    // Calculate current size based on age (expand over time)
                    const progress = effect.age / effect.maxLife;
                    
                    // Inner circle - expands over time but starts larger
                    const innerRadius = (0.15 + progress * radius * CONFIG.impactSize); // Use configurable impact size with minimum
                    
                    // Update inner circle geometry
                    globeGroup.remove(effect.circle);
                    if (effect.circle.geometry) {
                        effect.circle.geometry.dispose();
                    }
                    
                    // Create new ring geometry with updated size
                    // Keep the ring border width proportional to its size
                    const borderWidth = innerRadius * 0.2; // Border is 20% of the radius
                    const newGeometry = new THREE.RingGeometry(
                        innerRadius - borderWidth, // Inner radius of the ring 
                        innerRadius,               // Outer radius of the ring
                        24                         // More segments for a smoother ring
                    );
                    effect.circle.geometry = newGeometry;
                    
                    // Update inner circle opacity (fade out towards the end)
                    effect.circleMaterial.opacity = Math.max(0, 0.8 * (1 - Math.pow(progress, 1.5)));
                    
                    // Add back to scene
                    globeGroup.add(effect.circle);
                    
                    // Outer circle (expands faster)
                    const outerRadius = innerRadius * 1.3; // 30% larger than inner circle
                    
                    // Update outer circle geometry
                    globeGroup.remove(effect.outerCircle);
                    if (effect.outerCircle.geometry) {
                        effect.outerCircle.geometry.dispose();
                    }
                    
                    // Create new outer ring geometry with updated size
                    // Keep the ring border width proportional to its size
                    const outerBorderWidth = outerRadius * 0.15; // Slightly thinner border for outer ring
                    const newOuterGeometry = new THREE.RingGeometry(
                        outerRadius - outerBorderWidth, // Inner radius of the ring
                        outerRadius,                    // Outer radius of the ring
                        24                              // More segments for a smoother ring
                    );
                    effect.outerCircle.geometry = newOuterGeometry;
                    
                    // Update outer circle opacity (fade out faster)
                    effect.outerCircleMaterial.opacity = Math.max(0, 0.6 * (1 - Math.pow(progress, 2)));
                    
                    // Add back to scene
                    globeGroup.add(effect.outerCircle);
                    
                    // Move slightly behind to avoid z-fighting as they grow
                    const directionToCenter = new THREE.Vector3(0, 0, 0).sub(effect.outerCircle.position).normalize();
                    effect.outerCircle.position.copy(effect.circle.position);
                    effect.outerCircle.position.add(directionToCenter.multiplyScalar(0.01));
                    
                    // Make sure the circles are tangent to the globe surface
                    effect.circle.lookAt(new THREE.Vector3(0, 0, 0));
                    effect.outerCircle.lookAt(new THREE.Vector3(0, 0, 0));
                } else {
                    // Smoother transition at the end of effect - fade to zero before removing
                    if (effect.circleMaterial.opacity > 0.05) {
                        // Rapidly fade out remaining opacity of the expanding rings
                        effect.circleMaterial.opacity *= 0.7;
                        effect.outerCircleMaterial.opacity *= 0.7;
                        
                        // Skip to next iteration but don't remove the effect yet
                        continue;
                    }
                    
                    // Remove expanding rings now
                    globeGroup.remove(effect.circle);
                    if (effect.circle.geometry) {
                        effect.circle.geometry.dispose();
                    }
                    effect.circleMaterial.dispose();
                    
                    // Remove outer expanding circle
                    globeGroup.remove(effect.outerCircle);
                    if (effect.outerCircle.geometry) {
                        effect.outerCircle.geometry.dispose();
                    }
                    effect.outerCircleMaterial.dispose();
                    
                    // Mark expanding rings as removed
                    effect.ringsRemoved = true;
                    
                    // For effects not linked to arcs, start fading out the bullseye
                    if (!effect.linkedToArc && !effect.isFadingOut) {
                        console.log("Starting fade out for unlinked impact effect");
                        
                        // Mark the effect as fading
                        effect.isFadingOut = true;
                        effect.fadeStartTime = performance.now() / 1000;
                        effect.fadeDuration = 1.0; // 1 second fade-out duration
                    }
                }
                }
            } // Close the frame skipping condition
            
            // Hover effects for land points
            if (!isDragging) {
                // Cast a ray from the mouse position
                raycaster.setFromCamera(mouse, camera);
                
                // Check if the ray intersects with the globe
                const globeIntersects = raycaster.intersectObject(globe);
                
                if (globeIntersects.length > 0) {
                    // Get the intersection point on the globe in local coordinates
                    // This is critical to account for the globe's rotation
                    const currentIntersectionPoint = globeIntersects[0].point.clone();
                    
                    // Convert world coordinates to globe's local coordinates
                    // This accounts for the globe rotation
                    globeGroup.worldToLocal(currentIntersectionPoint);
                    
                    // Store a static reference for the intersection point
                    if (!window.lastIntersectionPoint) {
                        window.lastIntersectionPoint = currentIntersectionPoint.clone();
                    }
                    
                    // More responsive transition for the focused hover effect
                    // Increase the lerp factor for quicker response while still maintaining some smoothing
                    window.lastIntersectionPoint.lerp(currentIntersectionPoint, 0.3); // Higher interpolation factor for faster response
                    
                    // Use the smoothed intersection point
                    const intersectionPoint = window.lastIntersectionPoint;
                    
                    // Reference to the instanced dots
                    const instancedDots = landDots.userData.instancedDots;
                    
                    // Calculate hover effects for all land points based on distance
                    if (instancedDots) {
                        // Create a new Matrix4 and Quaternion for updating dots
                        const matrix = new THREE.Matrix4();
                        const quaternion = new THREE.Quaternion();
                        const position = new THREE.Vector3();
                        const scale = new THREE.Vector3(1, 1, 1);
                        
                        // For the more focused hover effect, we need dense point processing in the hover area
                        // Even in high performance mode, we process all points for consistency
                        const skipPoints = 1; // Never skip points for more precise hover effect
                        
                        for (let i = 0; i < landPoints.length; i += skipPoints) {
                            const dot = landPoints[i];
                            
                            // Get original position
                            const originalPos = dot.originalPosition;
                            
                            // Calculate distance to intersection point
                            const distance = originalPos.distanceTo(intersectionPoint);
                            
                            // Convert distance to an effect factor
                            // Closer points should rise more, with a much tighter, localized falloff
                            const maxDistance = radius * CONFIG.hoverPull; // Significantly reduced max distance for a much more focused effect
                            
                            if (distance < maxDistance) {
                                // Calculate a much more focused hover effect with steeper falloff
                                // Use a sharper exponential curve for more localized effect
                                const normalizedDist = distance / maxDistance;
                                
                                // Create a steeper falloff using higher power exponent
                                // This will make the effect drop off much more quickly with distance
                                const bellCurve = Math.cos(normalizedDist * Math.PI * 0.5);
                                const exponentialFalloff = Math.pow(bellCurve, 4); // Higher power for much steeper falloff
                                const smoothFactor = exponentialFalloff * CONFIG.hoverEffect * 1.5; // Slightly intensify the center effect
                                
                                // Apply hover effect - move dot outward from globe center
                                const direction = originalPos.clone().normalize();
                                const newPosition = originalPos.clone().add(
                                    direction.multiplyScalar(radius * smoothFactor)
                                );
                                
                                // Update matrix for this instance
                                position.copy(newPosition);
                                
                                // Orient dot to face outward
                                const normal = newPosition.clone().normalize();
                                const lookAt = position.clone().add(normal);
                                const up = new THREE.Vector3(0, 1, 0);
                                const rotationMatrix = new THREE.Matrix4().lookAt(position, lookAt, up);
                                quaternion.setFromRotationMatrix(rotationMatrix);
                                
                                // Create matrix in local coordinates
                                matrix.compose(position, quaternion, scale);
                                
                                // Set matrix in local space - globeGroup rotation is automatically applied
                                instancedDots.setMatrixAt(dot.index, matrix);
                            }
                            else {
                                // Reset to original position if not affected
                                position.copy(originalPos);
                                
                                // Orient dot to face outward
                                const normal = originalPos.clone().normalize();
                                const lookAt = position.clone().add(normal);
                                const up = new THREE.Vector3(0, 1, 0);
                                const rotationMatrix = new THREE.Matrix4().lookAt(position, lookAt, up);
                                quaternion.setFromRotationMatrix(rotationMatrix);
                                
                                // Create matrix in local coordinates
                                matrix.compose(position, quaternion, scale);
                                
                                // Set matrix in local space - globeGroup rotation is automatically applied
                                instancedDots.setMatrixAt(dot.index, matrix);
                            }
                        }
                        
                        // Update the instance matrices
                        instancedDots.instanceMatrix.needsUpdate = true;
                    }
                }
            }
            
            renderer.render(scene, camera);
        }
        
        // Function to initialize multiple arcs at startup
        function initializeArcs() {
            // Create a initial batch of arcs to start with
            const initialArcCount = Math.floor(CONFIG.maxConcurrentArcs * 0.5); // Start with 50% of max arcs
            console.log(`Creating ${initialArcCount} initial arcs...`);
            
            // Create arcs with varied growth progress
            for (let i = 0; i < initialArcCount; i++) {
                // Create the arc
                addRandomArc();
                
                // Set random initial age so arcs don't all grow/fade simultaneously
                if (arcs.length > 0) {
                    const randomProgress = Math.random();
                    const arc = arcs[arcs.length - 1];
                    
                    // Set up initial age to have arcs in various stages
                    if (randomProgress < 0.7) {
                        // 70% of initial arcs in growth phase
                        arc.age = arc.growDuration * Math.random() * 0.9;
                    } else {
                        // 30% in retreat phase
                        arc.age = arc.growDuration + (Math.random() * arc.maxLife * 0.5);
                    }
                }
            }
        }
        
        // Initialize arcs before starting animation
        initializeArcs();
        
        // Start animation loop
        animate(0);
        // FPS Counter
        const fpsCounter = document.getElementById('fps-counter');
        let frameCount = 0;
        let lastFPSUpdate = performance.now();
        let fps = 0;
        
        // Debug panel functionality
        const debugToggle = document.getElementById('debug-toggle');
        const debugPanel = document.getElementById('debug-panel');
        
        // Toggle debug panel visibility
        debugToggle.addEventListener('click', () => {
            if (debugPanel.style.display === 'block') {
                debugPanel.style.display = 'none';
                // Enable globe interaction again
                document.body.classList.remove('debug-panel-active');
            } else {
                debugPanel.style.display = 'block';
                // Disable globe interaction while debug panel is active
                document.body.classList.add('debug-panel-active');
                // Initialize controls with current config values
                updateControlsFromConfig();
            }
        });
        
        // Initialize controls with config values
        function updateControlsFromConfig() {
            // Globe appearance
            document.getElementById('globeRadius').value = CONFIG.globeRadius;
            document.getElementById('globeSegments').value = CONFIG.globeSegments;
            document.getElementById('showAtmosphere').checked = true; // Default to visible
            document.getElementById('atmosphereOpacity').value = CONFIG.atmosphereOpacity;
            document.getElementById('atmosphereGlow').value = CONFIG.atmosphereGlow;
            
            // Land points
            document.getElementById('showLandPoints').checked = true; // Default to visible
            document.getElementById('disableHover').checked = false; // Default to enabled
            document.getElementById('numPoints').value = CONFIG.numPoints;
            document.getElementById('dotSize').value = CONFIG.dotSize;
            document.getElementById('dotOpacity').value = CONFIG.dotOpacity;
            document.getElementById('hoverEffect').value = CONFIG.hoverEffect;
            
            // Arcs
            document.getElementById('showArcs').checked = true; // Default to visible
            document.getElementById('maxConcurrentArcs').value = CONFIG.maxConcurrentArcs;
            document.getElementById('arcFrequency').value = CONFIG.arcFrequency;
            document.getElementById('arcThickness').value = CONFIG.arcThickness;
            document.getElementById('arcPointsCount').value = CONFIG.arcPointsCount;
            
            // Animation
            document.getElementById('rotationSpeed').value = CONFIG.rotationSpeed;
            document.getElementById('arcGrowDuration').value = CONFIG.arcGrowDuration;
            document.getElementById('arcRetreatDuration').value = CONFIG.arcRetreatDuration;
            
            // Rendering
            document.getElementById('useHighPerformanceMode').checked = CONFIG.useHighPerformanceMode;
            document.getElementById('skipFrames').value = CONFIG.skipFrames;
            document.getElementById('pixelRatio').value = window.devicePixelRatio > 1 ? 1 : 0.5;
            document.getElementById('disableLights').checked = false;
            document.getElementById('freezeAnimations').checked = false;
            document.getElementById('disableRotation').checked = false;
        }
        
        // Apply control changes to config and update visualization
        function setupControlListeners() {
            // Globe appearance
            document.getElementById('globeRadius').addEventListener('input', (e) => {
                CONFIG.globeRadius = parseFloat(e.target.value);
                updateGlobeGeometry();
            });
            
            document.getElementById('globeSegments').addEventListener('input', (e) => {
                CONFIG.globeSegments = parseInt(e.target.value);
                updateGlobeGeometry();
            });
            
            document.getElementById('showAtmosphere').addEventListener('change', (e) => {
                const isVisible = e.target.checked;
                toggleAtmosphere(isVisible);
            });
            
            document.getElementById('atmosphereOpacity').addEventListener('input', (e) => {
                CONFIG.atmosphereOpacity = parseFloat(e.target.value);
                updateAtmosphere();
            });
            
            document.getElementById('atmosphereGlow').addEventListener('input', (e) => {
                CONFIG.atmosphereGlow = parseFloat(e.target.value);
                updateAtmosphere();
            });
            
            // Land points
            document.getElementById('showLandPoints').addEventListener('change', (e) => {
                const isVisible = e.target.checked;
                toggleLandPoints(isVisible);
            });
            
            document.getElementById('disableHover').addEventListener('change', (e) => {
                const disableHover = e.target.checked;
                toggleHoverEffects(!disableHover);
            });
            
            document.getElementById('numPoints').addEventListener('change', (e) => {
                CONFIG.numPoints = parseInt(e.target.value);
                regenerateLandPoints();
            });
            
            document.getElementById('dotSize').addEventListener('input', (e) => {
                CONFIG.dotSize = parseFloat(e.target.value);
                updateLandPointsGeometry();
            });
            
            document.getElementById('dotOpacity').addEventListener('input', (e) => {
                CONFIG.dotOpacity = parseFloat(e.target.value);
                updateLandPointsMaterial();
            });
            
            document.getElementById('hoverEffect').addEventListener('input', (e) => {
                CONFIG.hoverEffect = parseFloat(e.target.value);
                // Effect will be applied on next hover
            });
            
            // Arcs
            document.getElementById('showArcs').addEventListener('change', (e) => {
                const isVisible = e.target.checked;
                toggleArcs(isVisible);
            });
            
            document.getElementById('maxConcurrentArcs').addEventListener('input', (e) => {
                CONFIG.maxConcurrentArcs = parseInt(e.target.value);
                // Will affect future arc generation
            });
            
            document.getElementById('arcFrequency').addEventListener('input', (e) => {
                CONFIG.arcFrequency = parseFloat(e.target.value);
                // Will affect future arc timing
            });
            
            document.getElementById('arcThickness').addEventListener('input', (e) => {
                CONFIG.arcThickness = parseFloat(e.target.value);
                updateArcGeometry();
            });
            
            document.getElementById('arcPointsCount').addEventListener('change', (e) => {
                CONFIG.arcPointsCount = parseInt(e.target.value);
                // Will affect future arc geometry
            });
            
            // Animation
            document.getElementById('rotationSpeed').addEventListener('input', (e) => {
                CONFIG.rotationSpeed = parseFloat(e.target.value);
                // Will affect animation speed
            });
            
            document.getElementById('arcGrowDuration').addEventListener('input', (e) => {
                CONFIG.arcGrowDuration = parseFloat(e.target.value);
                // Will affect future arc animations
            });
            
            document.getElementById('arcRetreatDuration').addEventListener('input', (e) => {
                CONFIG.arcRetreatDuration = parseFloat(e.target.value);
                // Will affect future arc animations
            });
            
            // Rendering
            document.getElementById('useHighPerformanceMode').addEventListener('change', (e) => {
                CONFIG.useHighPerformanceMode = e.target.checked;
                updateRendererSettings();
            });
            
            document.getElementById('skipFrames').addEventListener('input', (e) => {
                CONFIG.skipFrames = parseInt(e.target.value);
                // Will affect frame skipping immediately
            });
            
            document.getElementById('pixelRatio').addEventListener('input', (e) => {
                const ratio = parseFloat(e.target.value);
                setPixelRatio(ratio);
            });
            
            document.getElementById('disableLights').addEventListener('change', (e) => {
                const disableLights = e.target.checked;
                toggleLights(!disableLights);
            });
            
            document.getElementById('freezeAnimations').addEventListener('change', (e) => {
                const freezeAnimations = e.target.checked;
                toggleAnimations(!freezeAnimations);
            });
            
            document.getElementById('disableRotation').addEventListener('change', (e) => {
                const disableRotation = e.target.checked;
                toggleRotation(!disableRotation);
            });
        }
        
        // Call to set up all control listeners
        setupControlListeners();
        
        // Prevent interaction with the globe when using the debug controls
        const debugControls = document.getElementById('debug-panel').querySelectorAll('input, button, select');
        debugControls.forEach(control => {
            // Prevent any pointer events from propagating when interacting with controls
            control.addEventListener('pointerdown', e => {
                e.stopPropagation();
            });
            
            // For sliders, also handle specific events
            if (control.type === 'range') {
                control.addEventListener('input', e => {
                    e.stopPropagation();
                });
                
                // While dragging sliders, keep the body in debug-panel-active mode
                control.addEventListener('pointerdown', () => {
                    document.body.classList.add('debug-panel-active');
                });
                
                // When done dragging, we'll keep the debug-panel-active class
                // since the panel is still open
            }
        });
        
        // Update globe geometry when radius or segments change
        function updateGlobeGeometry() {
            const newGlobeGeometry = new THREE.SphereGeometry(
                CONFIG.globeRadius,
                CONFIG.globeSegments,
                CONFIG.globeSegments
            );
            
            globe.geometry.dispose();
            globe.geometry = newGlobeGeometry;
            
            // Update related geometries
            updateAtmosphereGeometry();
        }
        
        // Update atmosphere geometry and properties
        function updateAtmosphereGeometry() {
            const atmosphereSize = CONFIG.globeRadius * CONFIG.atmosphereSize * 1.05;
            const newAtmosphereGeometry = new THREE.SphereGeometry(
                atmosphereSize,
                CONFIG.globeSegments,
                CONFIG.globeSegments
            );
            
            globeGroup.userData.atmosphere.geometry.dispose();
            globeGroup.userData.atmosphere.geometry = newAtmosphereGeometry;
        }
        
        // Update atmosphere material properties
        function updateAtmosphere() {
            if (globeGroup.userData.atmosphere && globeGroup.userData.atmosphere.material) {
                globeGroup.userData.atmosphere.material.uniforms.opacity.value = CONFIG.atmosphereOpacity * 1.5;
            }
            
            if (globeGroup.userData.atmosphereLight) {
                globeGroup.userData.atmosphereLight.intensity = CONFIG.atmosphereGlow * 1.5;
            }
            
            if (globeGroup.userData.atmosphereLight2) {
                globeGroup.userData.atmosphereLight2.intensity = CONFIG.atmosphereGlow * 0.8;
            }
        }
        
        // Update land points geometry
        function updateLandPointsGeometry() {
            // First, check if we have land points
            if (window.landDots && window.landDots.userData && window.landDots.userData.instancedDots) {
                const instancedDots = window.landDots.userData.instancedDots;
                // For instanced meshes, we update the geometry once
                if (instancedDots.geometry) {
                    // Dispose old geometry
                    instancedDots.geometry.dispose();
                    
                    // Create new geometry with updated size
                    instancedDots.geometry = new THREE.SphereGeometry(
                        CONFIG.dotSize,
                        CONFIG.dotSegments,
                        CONFIG.dotSegments
                    );
                }
            }
            
            // Also handle any non-instanced points if they exist
            if (window.landPoints && window.landPoints.length > 0) {
                const newDotGeometry = new THREE.SphereGeometry(
                    CONFIG.dotSize,
                    CONFIG.dotSegments,
                    CONFIG.dotSegments
                );
                
                // Update all individual land point geometries if any
                window.landPoints.forEach(dot => {
                    if (dot.geometry) {
                        dot.geometry.dispose();
                        dot.geometry = newDotGeometry;
                    }
                });
            }
        }
        
        // Update land points material
        function updateLandPointsMaterial() {
            // Update instanced mesh material if it exists
            if (window.landDots && window.landDots.userData && window.landDots.userData.instancedDots) {
                const instancedDots = window.landDots.userData.instancedDots;
                if (instancedDots.material) {
                    instancedDots.material.opacity = CONFIG.dotOpacity;
                }
            }
            
            // Also update any individual land points if they exist
            if (window.landPoints && window.landPoints.length > 0) {
                window.landPoints.forEach(dot => {
                    if (dot.material) {
                        dot.material.opacity = CONFIG.dotOpacity;
                    }
                });
            }
        }
        
        // Regenerate all land points - more expensive operation
        function regenerateLandPoints() {
            // Store reference to regenerate function if it exists
            if (typeof createLandPoints === 'function') {
                // Clean up existing land dot instances
                if (window.landDots) {
                    // Clean up instanced mesh if it exists
                    if (window.landDots.userData && window.landDots.userData.instancedDots) {
                        const instancedDots = window.landDots.userData.instancedDots;
                        if (instancedDots.geometry) instancedDots.geometry.dispose();
                        if (instancedDots.material) instancedDots.material.dispose();
                        window.landDots.remove(instancedDots);
                    }
                    
                    // Clean up any other children
                    while (window.landDots.children.length > 0) {
                        const child = window.landDots.children[0];
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                        window.landDots.remove(child);
                    }
                    
                    // Reset userData
                    window.landDots.userData = {};
                }
                
                // Reset the landPoints array
                window.landPoints = [];
                
                // Regenerate land points with new config
                createLandPoints();
            }
        }
        
        // Make the regeneration functions available globally
        window.regenerateLandGeometry = updateLandPointsGeometry;
        window.updateLandMaterial = updateLandPointsMaterial;
        window.regenerateLandPoints = regenerateLandPoints;
        
        // Update arc geometry settings
        function updateArcGeometry() {
            // Update existing arc geometries with new thickness
            if (window.arcsGroup && window.arcsGroup.children && window.arcsGroup.children.length > 0) {
                // For existing arcs, update their thickness
                window.arcsGroup.children.forEach(arc => {
                    if (arc.children && arc.children.length > 0) {
                        // For each tube in the arc, update geometry if possible
                        arc.children.forEach(tube => {
                            if (tube.geometry && tube.userData && tube.userData.pathPoints) {
                                // Recreate tube with new thickness
                                const curvePoints = tube.userData.pathPoints;
                                const curve = new THREE.CatmullRomCurve3(curvePoints);
                                
                                // Dispose old geometry
                                tube.geometry.dispose();
                                
                                // Create new tube geometry with updated thickness
                                tube.geometry = new THREE.TubeGeometry(
                                    curve,
                                    CONFIG.arcTubeSegments,
                                    CONFIG.arcThickness,
                                    CONFIG.arcRadialSegments,
                                    false
                                );
                            }
                        });
                    }
                });
            }
            
            // Also handle arc array format if it exists
            if (window.arcs && window.arcs.length > 0) {
                window.arcs.forEach(arc => {
                    if (arc.tubeMesh && arc.tubeMesh.geometry && arc.points) {
                        // Recreate tube with new thickness
                        const curve = new THREE.CatmullRomCurve3(arc.points);
                        
                        // Dispose old geometry
                        arc.tubeMesh.geometry.dispose();
                        
                        // Create new tube geometry with updated thickness
                        arc.tubeMesh.geometry = new THREE.TubeGeometry(
                            curve,
                            CONFIG.arcTubeSegments,
                            CONFIG.arcThickness,
                            CONFIG.arcRadialSegments,
                            false
                        );
                    }
                });
            }
        }
        
        // Make the arc update function available globally
        window.updateArcGeometries = updateArcGeometry;
        
        // Toggle atmosphere visibility
        function toggleAtmosphere(isVisible) {
            if (globeGroup && globeGroup.userData) {
                // Toggle atmosphere mesh
                if (globeGroup.userData.atmosphere) {
                    globeGroup.userData.atmosphere.visible = isVisible;
                }
                
                // Toggle atmosphere lights
                if (globeGroup.userData.atmosphereLight) {
                    globeGroup.userData.atmosphereLight.intensity = isVisible ? CONFIG.atmosphereGlow * 1.5 : 0;
                }
                
                if (globeGroup.userData.atmosphereLight2) {
                    globeGroup.userData.atmosphereLight2.intensity = isVisible ? CONFIG.atmosphereGlow * 0.8 : 0;
                }
                
                // Toggle inner glow if it exists
                if (globeGroup.userData.innerGlow) {
                    globeGroup.userData.innerGlow.visible = isVisible;
                } else {
                    // Find inner glow by traversing children
                    globeGroup.children.forEach(child => {
                        if (child.material && child.material.type === 'MeshBasicMaterial' && 
                            child.material.side === THREE.BackSide) {
                            globeGroup.userData.innerGlow = child;
                            child.visible = isVisible;
                        }
                    });
                }
            }
        }
        
        // Toggle arcs visibility
        function toggleArcs(isVisible) {
            // Toggle all existing arcs
            if (window.arcsGroup) {
                window.arcsGroup.visible = isVisible;
            }
            
            // Also toggle arc generation
            window.arcsEnabled = isVisible;
            
            // If no dedicated property exists to control arc generation,
            // store the original value and set to very low value to effectively disable
            if (!isVisible) {
                // Store original frequency if not already stored
                if (window.originalArcFrequency === undefined) {
                    window.originalArcFrequency = CONFIG.arcFrequency;
                }
                // Set to very high value to effectively disable new arcs
                CONFIG.arcFrequency = 1000;
            } else if (window.originalArcFrequency !== undefined) {
                // Restore original frequency
                CONFIG.arcFrequency = window.originalArcFrequency;
            }
        }
        
        // Toggle land points visibility
        function toggleLandPoints(isVisible) {
            if (window.landDots) {
                window.landDots.visible = isVisible;
            }
        }
        
        // Toggle hover effects
        function toggleHoverEffects(enabled) {
            // Store the state globally
            window.hoverEffectsEnabled = enabled;
            
            // If your code uses event listeners for hover effects,
            // you may need to add/remove them here or check this flag in those handlers
        }
        
        // Set pixel ratio
        function setPixelRatio(ratio) {
            if (renderer) {
                renderer.setPixelRatio(ratio);
            }
        }
        
        // Toggle lights
        function toggleLights(enabled) {
            // Store original intensities if not already stored
            if (!window.originalLightIntensities && enabled === false) {
                window.originalLightIntensities = {};
                
                // Store ambient light
                if (ambientLight) {
                    window.originalLightIntensities.ambient = ambientLight.intensity;
                }
                
                // Store directional light
                if (directionalLight) {
                    window.originalLightIntensities.directional = directionalLight.intensity;
                }
                
                // Store back light
                if (backLight) {
                    window.originalLightIntensities.back = backLight.intensity;
                }
                
                // Store secondary back light
                if (secondBackLight) {
                    window.originalLightIntensities.secondBack = secondBackLight.intensity;
                }
                
                // Store third back light
                if (thirdBackLight) {
                    window.originalLightIntensities.thirdBack = thirdBackLight.intensity;
                }
                
                // Store rim light
                if (rimLight) {
                    window.originalLightIntensities.rim = rimLight.intensity;
                }
                
                // Store fill light
                if (fillLight) {
                    window.originalLightIntensities.fill = fillLight.intensity;
                }
            }
            
            // Set all light intensities
            if (enabled && window.originalLightIntensities) {
                // Restore original intensities
                if (ambientLight && window.originalLightIntensities.ambient !== undefined) {
                    ambientLight.intensity = window.originalLightIntensities.ambient;
                }
                
                if (directionalLight && window.originalLightIntensities.directional !== undefined) {
                    directionalLight.intensity = window.originalLightIntensities.directional;
                }
                
                if (backLight && window.originalLightIntensities.back !== undefined) {
                    backLight.intensity = window.originalLightIntensities.back;
                }
                
                if (secondBackLight && window.originalLightIntensities.secondBack !== undefined) {
                    secondBackLight.intensity = window.originalLightIntensities.secondBack;
                }
                
                if (thirdBackLight && window.originalLightIntensities.thirdBack !== undefined) {
                    thirdBackLight.intensity = window.originalLightIntensities.thirdBack;
                }
                
                if (rimLight && window.originalLightIntensities.rim !== undefined) {
                    rimLight.intensity = window.originalLightIntensities.rim;
                }
                
                if (fillLight && window.originalLightIntensities.fill !== undefined) {
                    fillLight.intensity = window.originalLightIntensities.fill;
                }
            } else if (!enabled) {
                // Set all lights to 0 intensity
                if (ambientLight) ambientLight.intensity = 0;
                if (directionalLight) directionalLight.intensity = 0;
                if (backLight) backLight.intensity = 0;
                if (secondBackLight) secondBackLight.intensity = 0;
                if (thirdBackLight) thirdBackLight.intensity = 0;
                if (rimLight) rimLight.intensity = 0;
                if (fillLight) fillLight.intensity = 0;
            }
        }
        
        // Toggle animations
        function toggleAnimations(enabled) {
            window.animationsEnabled = enabled;
            
            // Your animation code should check this flag
            // This will depend on how animations are implemented
        }
        
        // Toggle globe rotation
        function toggleRotation(enabled) {
            window.rotationEnabled = enabled;
            
            // If rotation is disabled, store the current speed and set to 0
            if (!enabled) {
                if (window.originalRotationSpeed === undefined) {
                    window.originalRotationSpeed = CONFIG.rotationSpeed;
                }
                CONFIG.rotationSpeed = 0;
            } else if (window.originalRotationSpeed !== undefined) {
                // Restore original rotation speed
                CONFIG.rotationSpeed = window.originalRotationSpeed;
            }
        }
        
        // Update renderer settings for performance mode
        function updateRendererSettings() {
            renderer.setPixelRatio(CONFIG.useHighPerformanceMode ? 1 : 
                              (window.devicePixelRatio > 2 ? 1.5 : window.devicePixelRatio));
                              
            renderer.antialias = !CONFIG.useHighPerformanceMode;
            renderer.compile(scene, camera);
        }
        
        // Enhanced FPS counter with detailed metrics and uncapped mode
        let lastFrameTime = performance.now();
        let frameCounter = 0;
        let frameTimes = [];
        let renderTimes = [];
        let isUncapped = false;
        let showDetailedMetrics = false;
        let currentFps = 0;
        let potentialFps = 0;
        let avgRenderTime = 0;
        let lastRenderStart = 0;
        
        // Set initial state for performance toggles
        window.rotationEnabled = true;
        window.animationsEnabled = true;
        window.hoverEffectsEnabled = true;
        
        // Uncap FPS by using setTimeout instead of requestAnimationFrame
        // Store original requestAnimationFrame for later restoration
        const originalRequestAnimationFrame = window.requestAnimationFrame;
        const originalCancelAnimationFrame = window.cancelAnimationFrame;
        
        // Function to toggle between capped and uncapped FPS
        function toggleUncappedFps(enabled) {
            isUncapped = enabled;
            
            if (enabled) {
                // Replace with setTimeout-based implementation for uncapped performance
                window.requestAnimationFrame = function(callback) {
                    return setTimeout(() => {
                        callback(performance.now());
                    }, 0);
                };
                
                window.cancelAnimationFrame = function(id) {
                    clearTimeout(id);
                };
            } else {
                // Restore original browser implementation (capped to refresh rate)
                window.requestAnimationFrame = originalRequestAnimationFrame;
                window.cancelAnimationFrame = originalCancelAnimationFrame;
            }
        }
        
        // Set up listeners for the uncapped FPS toggle
        document.getElementById('uncapFps').addEventListener('change', function(e) {
            toggleUncappedFps(e.target.checked);
        });
        
        // Set up listeners for detailed metrics display
        document.getElementById('showDetailedMetrics').addEventListener('change', function(e) {
            showDetailedMetrics = e.target.checked;
        });
        
        // Function to update FPS display with improved metrics
        function updateFPS() {
            const now = performance.now();
            const frameTime = now - lastFrameTime;
            lastFrameTime = now;
            
            // Calculate render time from last frame
            if (lastRenderStart > 0) {
                const renderTime = now - lastRenderStart;
                if (renderTime > 0 && renderTime < 1000) {
                    renderTimes.push(renderTime);
                    if (renderTimes.length > 60) renderTimes.shift();
                    avgRenderTime = renderTimes.reduce((a, b) => a + b, 0) / renderTimes.length;
                    
                    // Calculate potential FPS (uncapped) based on render time
                    potentialFps = Math.round(1000 / avgRenderTime);
                }
            }
            
            // Record render start time for next frame
            lastRenderStart = now;
            
            // Track realistic frame times for FPS calculation
            if (frameTime > 0 && frameTime < 1000) {
                frameTimes.push(frameTime);
                if (frameTimes.length > 60) frameTimes.shift();
            }
            
            frameCounter++;
            
            // Update display every few frames
            if (frameCounter >= 10) {
                frameCounter = 0;
                
                // Calculate average FPS from frame times
                if (frameTimes.length > 0) {
                    const avgFrameTime = frameTimes.reduce((a, b) => a + b, 0) / frameTimes.length;
                    currentFps = Math.round(1000 / avgFrameTime);
                    
                    // Update FPS counter with appropriate information
                    if (showDetailedMetrics) {
                        fpsCounter.textContent = `FPS: ${currentFps} | Potential: ${potentialFps} | Render: ${avgRenderTime.toFixed(2)}ms`;
                    } else {
                        fpsCounter.textContent = `FPS: ${currentFps}${isUncapped ? ' (Uncapped)' : ''}`;
                    }
                }
            }
            
            // Continue measuring
            requestAnimationFrame(updateFPS);
        }
        
        // Start FPS measurement
        requestAnimationFrame(updateFPS);
    </script>
</body>
</html>