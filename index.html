<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Globe with Three.js</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; cursor: grab; }
        canvas:active { cursor: grabbing; }
    </style>
</head>
<body>
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script>
        // Configuration parameters for performance/quality tradeoff
        const CONFIG = {
            // Globe appearance
            globeRadius: 11,                  // Size of the globe
            globeSegments: 64,                // Resolution of the globe (32-128, lower for better performance)
            
            // Land points
            numPoints: 8000,                  // Maximum points to generate (3000-10000, lower for better performance)
            dotSize: 0.08,                    // Size of land dots (0.05-0.1)
            dotSegments: 6,                   // Land dot geometry segments (4-8, lower for better performance)
            
            // Arcs
            maxConcurrentArcs: 40,            // Maximum concurrent arcs (6-40, lower for better performance)
            arcFrequency: 0.2,                // How often new arcs appear (higher = less frequent)
            arcTimingVariation: 0.15,         // Randomness in arc timing (0-1, higher = more random)
            arcTubeSegments: 12,              // Maximum tube segments for arcs (6-16, lower for better performance) 
            arcRadialSegments: 4,             // Radial segments for arc tubes (3-8, lower for better performance)
            arcThickness: 0.06,               // Thickness of arcs (0.04-0.1)
            arcPointsCount: 35,               // Number of points in arc path (20-40, lower for better performance)
            
            // Animation and behavior
            rotationSpeed: 0.002,             // Speed of auto-rotation (0.001-0.003)
            arcGrowDuration: 0.7,             // Base duration for arc growth in seconds (0.5-1.5)
            arcRetreatDuration: 2.0,          // Base duration for arc retreat in seconds (0.8-3.0)
            
            // Impact effects
            impactSize: 0.08,                 // Maximum impact size as fraction of globe radius (0.05-0.2)
            
            // Rendering
            useHighPerformanceMode: false,    // Set true for better performance but lower visual quality
            skipFrames: 0                     // Number of frames to skip when updating (0-2, higher for better performance)
        };
        
        // Enable high performance mode if needed
        if (CONFIG.useHighPerformanceMode) {
            CONFIG.globeSegments = 32;
            CONFIG.numPoints = 4000;
            CONFIG.dotSegments = 4;
            CONFIG.maxConcurrentArcs = 25; // Still allow many arcs but reduced from normal mode
            CONFIG.arcFrequency = 0.3; // Slightly less frequent arc creation for performance
            CONFIG.arcTubeSegments = 8;
            CONFIG.arcRadialSegments = 3;
            CONFIG.arcPointsCount = 25;
            CONFIG.skipFrames = 1;
        }
        
        // Set up the scene, camera, and renderer
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000204); // Darker blue-black background for better contrast
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: !CONFIG.useHighPerformanceMode, // Disable antialiasing in high performance mode
            powerPreference: "high-performance" 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(CONFIG.useHighPerformanceMode ? 1 : window.devicePixelRatio); // Use lower pixel ratio in high performance mode
        document.body.appendChild(renderer.domElement);
        
        // Create a single parent group for the entire globe and all its elements
        const globeGroup = new THREE.Group();
        scene.add(globeGroup);
        
        // Create a blue globe with better material for lighting
        const radius = CONFIG.globeRadius;  // Use configurable radius
        const globeGeometry = new THREE.SphereGeometry(
            radius, 
            CONFIG.globeSegments, 
            CONFIG.globeSegments
        ); 
        const globeMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x0077be,
            shininess: 15,        // Reduced shininess to avoid shiny dots
            specular: 0x222233,   // Very subtle specular highlights
            emissive: 0x002244,   // Subtle blue glow
        });
        const globe = new THREE.Mesh(globeGeometry, globeMaterial);
        globeGroup.add(globe);
        
        // No separate atmosphere - we'll use lighting for glow effects
        
        // Enhanced lighting for better glow and highlights
        const ambientLight = new THREE.AmbientLight(0x333344, 0.5); // Subtle bluish ambient light
        scene.add(ambientLight);
        
        // Main directional light (sun-like) - reduced intensity
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(8, 8, 8);
        scene.add(directionalLight);
        
        // Add stronger blue backlight for glow effect
        const backLight = new THREE.PointLight(0x0055ff, 2.0, 50);
        backLight.position.set(-18, 5, -18);
        scene.add(backLight);
        
        // Add a blue rim light from below for additional glow
        const rimLight = new THREE.PointLight(0x0044ff, 1.0, 50);
        rimLight.position.set(-5, -15, -10);
        scene.add(rimLight);
        
        // Add a soft white fill light for general illumination
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
        fillLight.position.set(0, 15, 15);
        scene.add(fillLight);
        
        // Position camera
        camera.position.z = 28;
        
        // Load land coordinates (simplified version)
        const landPoints = [];
        const landDots = new THREE.Group();
        globeGroup.add(landDots);
        
        // Create land dots based on actual land/sea distribution
        function createLandPoints() {
            console.time('landPoints');
            // Using the landmasses object for land detection now

            // Resolution settings - use configurable options
            const dotSize = CONFIG.dotSize; // Use configurable dot size

            // High-resolution world map bitmap (simplified representation of Earth's land masses)
            // Each row represents a latitude band from 90째N to 90째S
            // Each character in a row represents a longitude band from 180째W to 180째E
            // 1 = land, 0 = water
            const worldMap = ["000000000000000000000000000000000000000000000000000000001111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000000000000111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000000000001111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000000000001111111110111111111111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000000000000111111000011111111111111111111110000000000000000000000000000000000000000000000000000011111111100000000000000000000000000000000000000000000000000", "000000000000000000000000000000001110000000000000000000000000000011111111111111111110000000000000000000000000000000000000000000000000111111111111100000000000000000000000000000000000000000000000000", "000000000000000000000000000000111111101110000000111111100000000011111111111111110000000000000000000000000000000000000000000011100111111111111111111100111100000011000000000000000000000000000000000", "000000000000001111100000000000111111111110011100111111111000000001111111111111110000000000000000000000000000000000000000000011111111111111111111111111111111110011111111110000000000000000000000000", "000000001111111111110000111110000111111110011100110111111000000001111111111111110000000000000000000001111111110000000000110011111111111111111111111111111111111111111111111111110011100000000000000", "000001111111111111111111111111111111111100111111110001111100001111111111111111100000000000000000000111111111111110001111111101111111111111111111111111111111111111111111111111111111111111000000000", "000111111111111111111111111111111111111111111111100001111100000111111111100000000000000000000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000", "001111111111111111111111111111111111111111111110000111111100000111111111000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000", "001111111111111111111111111111111111111111111000000111111000000111111000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111000", "111111111111111111111111111111111111111111110000010011110000000111111000000000000000000000000001111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000", "111111111111111111111111111111111111111110000000111100110000000011110000000000000000000000000011111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000", "111111111111111111111111111111111111111000000011111100110000000001100000000000000000000000000011111111011111111111111111111111111111111111111111111111111111111111111111111111111100011111100000000", "111110100000111111111111111111111111110000000011111111110000000000000000000000000000000000000011111111001111111111111111111111111111111111111111111111111111111111111111111111111100111101000000000", "011000000000011111111111111111111111111000000011111111110000000000000000000000000000000000000000011110111111111111111111111111111111111111111111111111111111111111111111111000000000111110000000000", "000000000000001111111111111111111111111111100011111111110000000000000000000000000000000000000000011110111111111111111111111111111111111111111111111111111111111111111111111000000000111111000000000", "000000000000011111111111111111111111111111111111111111111100000000000000000000000000000000000001111011111111111111111111111111111111111111111111111111111111111111111111111000000000011111000000000", "000000000000011111111111111111111111111111011111111111111100000000000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111100000001111000000000", "000000000000011111111111111111111111111111111111111111111100000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000111000000000", "000000000000011111111111111111111111111111111111111111111000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000011000000000", "000000000000001111111111111111111111111111111111111111000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000000000000", "000000000000011111111111111111111111111111111111111100000000000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000000000000", "000000000000011111111111111111111111111111111111111111000000000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000000000000", "000000000000111111111111111111111111111111111111111111000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000100000000000000", "000000000001111111111111111111111111111111111111111100000000000000000000000000000000011001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000110000000000000", "000000000001111111111111111111111111111111111110110000000000000000000000000000000000111111111110111111111111111111111111111111111111111111111111111111111111111111111111111111110000111000000000000", "000000000011111111111111111111111111111111111100000000000000000000000000000000000000111111111000011111111111111111111111111111111111111111111111111111111111111111111111111111000000111000000000000", "000000000111111111111111111111111111111111111000000000000000000000000000000000000000111111110000000111111111111111111111111111111111111111111111111111111111111111111111111111000000110000000000000", "000000000111111111111111111111111111111111100000000000000000000000000000000000000000111111100000000111111101111111111111111111111111111111111111111111111111111111111111011111000000110000000000000", "000000000111111111111111111111111111111111000000000000000000000000000000000000000000111111100000001110011101111111111111111111111111111111111111111111111111111111111110000111100010110000000000000", "000000000111111111111111111111111111111110000000000000000000000000000000000000000000111110011111111100011101111111111111111111111111111111111111111111111111111111111111110111110111111000000000000", "000000000111111111111111111111111111111110000000000000000000000000000000000000000000001111111111110000000000011011111111111111111111111111111111111111111111111111111111110011110111111000000000000", "000000000011111111111111111111111111111000000000000000000000000000000000000000000000011111111111100000000000000001111111111111111111111111111111111111111111111111111111110011100111110000000000000", "000000000001111111111111111111111111110000000000000000000000000000000000000000000001111111111111111000011000000001111111111111111111111111111111111111111111111111111111110000000000000000000000000", "000000000000111111111111111111111111100000000000000000000000000000000000000000000001111111111111111110011111110011111111111111111111111111111111111111111111111111111111111100000000000000000000000", "000000000001111111111111111111111111000000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000", "000000000000111111111111111111100111000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000", "000000000000111111111111110000000111000000000000000000000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000", "000000000000111111111111000000000111000000000000000000000000000000000000000000001111111111111111111111111111111110111111111101111111111111111111111111111111111111111111111100000000000000000000000", "000000000000011111111111000000000011000000000000000000000000000000000000000000011111111111111111111111111111111111111111111100011111111111111111111111111111111111111111111100000000000000000000000", "000000000000011011111111000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111011111111111111000001111111111111111111111111111111111111000000000000000000000000", "000000000000000011111111000000000000000000000000000000000000000000000000000000111111111111111111111111111111111111111111111111111110000011111111111111111111111111111111110000000000000000000000000", "000000000000000011111110000111000000000000000000000000000000000000000000000000111111111111111111111111111111111111101111111111111110000001111111111111111111111111111111000000000000000000000000000", "000000000000000001111111000111000000000000000000000000000000000000000000000000111111111111111111111111111111111111111111111111111110000000111111111111000111111111100110000000000000000000000000000", "000000000000000001111111101111000000000000000000000000000000000000000000000000111111111111111111111111111111111111110111111111111100000000001111111110000111111111101110000000000000000000000000000", "000000000000000001111111111111000000000000000000000000000000000000000000000000111111111111111111111111111111111111111011111111111000000000001111111100000011111111111100000000000000000000000000000", "000000000000000000011111111111100000000000000000000000000000000000000000000000111111111111111111111111111111111111111011111111110000000000001111111000000001111111111000000000000000000000000000000", "000000000000000000000111111111110000000000000000000000000000000000000000000001111111111111111111111111111111111111111101111111100000000000001111110000000001111111111000000000000000000000000000000", "000000000000000000000000011111110000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111110000000000000000111110000000000011111111100000000000000000000000000000", "000000000000000000000000000111110000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111000000000000000000111110000000000011111111100000000000000000000000000000", "000000000000000000000000000001110000001111000000000000000000000000000000000001111111111111111111111111111111111111111111000011000000000000000111110000000000011111111100000000000000000000000000000", "000000000000000000000000000001110000111111111100000000000000000000000000000000011111111111111111111111111111111111111111111111000000000000000011110000000000011111111100000000000000000000000000000", "000000000000000000000000000001111001111111111110000000000000000000000000000000011111111111111111111111111111111111111111111111000000000000000011110000000000011101111000000000000000000000000000000", "000000000000000000000000000000011101111111111111100000000000000000000000000000001111111111111111111111111111111111111111111110000000000000000001100000000000001100100000000000000000000000000000000", "000000000000000000000000000000000101111111111111110000000000000000000000000000000111111111111111111111111111111111111111111110000000000000000000000000000000000000000000001100000000000000000000000", "000000000000000000000000000000000001111111111111111110000000000000000000000000000111111111111111111111111111111111111111111100000000000000000000000000000000110000000000001110000000000000000000000", "000000000000000000000000000000000001111111111111111111000000000000000000000000000001111100000111111111111111111111111111111000000000000000000000000000000000111000000000111110000000000000000000000", "000000000000000000000000000000000011111111111111111111100000000000000000000000000000000000000000111111111111111111111111111000000000000000000000000000000000011100000001111110000000000000000000000", "000000000000000000000000000000000011111111111111111111100000000000000000000000000000000000000000111111111111111111111111110000000000000000000000000000000000011110000011111110000000000000000000000", "000000000000000000000000000000000111111111111111111111100000000000000000000000000000000000000000111111111111111111111111100000000000000000000000000000000000001111000111111110000000000000000000000", "000000000000000000000000000000001111111111111111111111111000000000000000000000000000000000000001111111111111111111111111000000000000000000000000000000000000000111100111111100000000011100000000000", "000000000000000000000000000000001111111111111111111111111111000000000000000000000000000000000001111111111111111111111111000000000000000000000000000000000000000111100011111100000000011101100000000", "000000000000000000000000000000000111111111111111111111111111111000000000000000000000000000000000111111111111111111111110000000000000000000000000000000000000000011110011111000000000001111111100000", "000000000000000000000000000000001111111111111111111111111111111110000000000000000000000000000000011111111111111111111100000000000000000000000000000000000000000011110000000000000000001111111111000", "000000000000000000000000000000001111111111111111111111111111111111000000000000000000000000000000011111111111111111111000000000000000000000000000000000000000000001110000000000000000000001111111100", "000000000000000000000000000000000111111111111111111111111111111111000000000000000000000000000000001111111111111111111100000000000000000000000000000000000000000000110000000000000000000000111111100", "000000000000000000000000000000000011111111111111111111111111111111000000000000000000000000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000111111110", "000000000000000000000000000000000011111111111111111111111111111110000000000000000000000000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000011101111", "000000000000000000000000000000000001111111111111111111111111111100000000000000000000000000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000111", "000000000000000000000000000000000001111111111111111111111111111100000000000000000000000000000000000111111111111111111100000000000000000000000000000000000000000000000000000000000000011110001100001", "000000000000000000000000000000000001111111111111111111111111111100000000000000000000000000000000001111111111111111111100000110000000000000000000000000000000000000000000000000000000111110001100000", "000000000000000000000000000000000000111111111111111111111111111000000000000000000000000000000000001111111111111111111100001110000000000000000000000000000000000000000000000000001111111100011100000", "000000000000000000000000000000000000011111111111111111111111111000000000000000000000000000000000011111111111111111111100111110000000000000000000000000000000000000000000000000011111111110011110000", "000000000000000000000000000000000000001111111111111111111111111000000000000000000000000000000000011111111111111111111000111110000000000000000000000000000000000000000000000000111111111111111110000", "000000000000000000000000000000000000000011111111111111111111111000000000000000000000000000000000011111111111111111110000111110000000000000000000000000000000000000000000000001111111111111111110000", "000000000000000000000000000000000000000001111111111111111111111000000000000000000000000000000000001111111111111111100000111100000000000000000000000000000000000000000000000011111111111111111111000", "000000000000000000000000000000000000000001111111111111111111110000000000000000000000000000000000001111111111111111100001111100000000000000000000000000000000000000000000011111111111111111111111000", "000000000000000000000000000000000000000001111111111111111111110000000000000000000000000000000000000111111111111111100001111000000000000000000000000000000000000000000001111111111111111111111111100", "000000000000000000000000000000000000000001111111111111111111110000000000000000000000000000000000000111111111111111100001111000000000000000000000000000000000000000000001111111111111111111111111110", "000000000000000000000000000000000000000001111111111111111110000000000000000000000000000000000000000111111111111111100001111000000000000000000000000000000000000000000001111111111111111111111111110", "000000000000000000000000000000000000000001111111111111111000000000000000000000000000000000000000000111111111111111000001111000000000000000000000000000000000000000000001111111111111111111111111110", "000000000000000000000000000000000000000001111111111111111100000000000000000000000000000000000000000011111111111110000000000000000000000000000000000000000000000000000001111111111111111111111111110", "000000000000000000000000000000000000000001111111111111111000000000000000000000000000000000000000000011111111111100000000000000000000000000000000000000000000000000000011111111111111111111111111110", "000000000000000000000000000000000000000001111111111111111000000000000000000000000000000000000000000011111111111100000000000000000000000000000000000000000000000000000011111111111111111111111111110", "000000000000000000000000000000000000000001111111111111110000000000000000000000000000000000000000000001111111111000000000000000000000000000000000000000000000000000000001111111111111111111111111110", "000000000000000000000000000000000000000001111111111111110000000000000000000000000000000000000000000001111111110000000000000000000000000000000000000000000000000000000001111111111111111111111111100", "000000000000000000000000000000000000000000111111111111100000000000000000000000000000000000000000000000111111100000000000000000000000000000000000000000000000000000000011111111100011111111111111000", "000000000000000000000000000000000000000000111111111111100000000000000000000000000000000000000000000000111110000000000000000000000000000000000000000000000000000000000011111100000001111111111110000", "000000000000000000000000000000000000000000111111111110000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000011000000000000011111111100000", "000000000000000000000000000000000000000000111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111000000", "000000000000000000000000000000000000000000111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111110000000", "000000000000000000000000000000000000000000111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001111000000000", "000000000000000000000000000000000000000000111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000011111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000011111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000001111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000011111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000011111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000001111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000001111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000000111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000000011110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"];
            
            // Helper function to check if a point is on land
            function isLand(lat, lon) {
                // Convert to map indices - the worldMap has lat from 90째N to 90째S (top to bottom)
                // Note: We use worldMap.length - 1 - latIndex to flip the y-axis since worldMap is stored top to bottom
                const latIndex = Math.min(worldMap.length - 1, Math.max(0, Math.floor((90 - lat) * worldMap.length / 180)));
                const lonIndex = Math.min(worldMap[0].length - 1, Math.max(0, Math.floor((lon + 180) * worldMap[0].length / 360)));
                
                return worldMap[latIndex][lonIndex] === '1';
            }
            
            // Create points in a more even distribution using the Fibonacci lattice
            // This avoids concentration at the poles
            const numPoints = CONFIG.numPoints; // Use configurable number of points
            
            for (let i = 0; i < numPoints; i++) {
                // Fibonacci lattice formula for even distribution on a sphere
                const phi = Math.acos(1 - 2 * (i + 0.5) / numPoints);
                const theta = Math.PI * (1 + Math.sqrt(5)) * (i + 0.5);
                
                // Convert to lat/lon
                const lat = 90 - (phi * 180 / Math.PI);
                const lon = (theta * 180 / Math.PI) % 360 - 180;
                
                // Only place a dot if the map indicates land
                if (isLand(lat, lon)) {
                        // Convert lat/lon to 3D coordinates
                        // Note the negative sign on x to correctly orient the globe
                        const phi = (90 - lat) * Math.PI / 180;
                        const theta = (lon + 180) * Math.PI / 180;
                        
                        // Lift the points slightly off the globe's surface for better visibility
                        const pointRadius = radius * 1.005; // 0.5% larger than globe radius
                        const x = -pointRadius * Math.sin(phi) * Math.cos(theta);
                        const y = pointRadius * Math.cos(phi);
                        const z = pointRadius * Math.sin(phi) * Math.sin(theta);
                        
                        // Use flat circles for performance with higher dot count
                        const dotGeometry = new THREE.CircleGeometry(dotSize, CONFIG.dotSegments); // Use configurable segment count
                        const dotMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0xddddff, // Slight blue tint to match the globe better
                            side: THREE.DoubleSide, // Make sure circles are visible from both sides
                            transparent: true,
                            opacity: 0.85 // Slightly more transparent to reduce shine
                        });
                        const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                        
                        // Position the dot at the surface of the globe
                        dot.position.set(x, y, z);
                        
                        // Make the circle face outward from center of globe
                        const lookAt = new THREE.Vector3(0, 0, 0);
                        dot.lookAt(lookAt);
                        dot.userData = { 
                            originalPosition: new THREE.Vector3(x, y, z),
                            hovering: false,
                            phi: phi,
                            theta: theta
                        };
                        
                        landDots.add(dot);
                        landPoints.push(dot);
                }
            }
        }
        
        createLandPoints();
        console.timeEnd('landPoints');
        console.log(`Created ${landPoints.length} land points`);
        
        // Arcs between points
        const arcs = [];
        
        function createArc(startPoint, endPoint) {
            const startPos = startPoint.position.clone();
            const endPos = endPoint.position.clone();
            
            // Calculate a curved path between points
            const midPoint = startPos.clone().add(endPos).multiplyScalar(0.5);
            const distance = startPos.distanceTo(endPos);
            
            // Make the arc height relative to distance but ensure it touches the globe
            // Height of the arc depends on distance but is more rounded
            midPoint.normalize().multiplyScalar(radius + distance * 0.95); // Higher, more rounded arcs
            
            // Slightly adjust start and end points to ensure arcs touch the globe
            const adjustStartPos = startPos.clone().normalize().multiplyScalar(radius * 0.997);
            const adjustEndPos = endPos.clone().normalize().multiplyScalar(radius * 0.997);
            
            // Calculate all points for the complete path
            const allPoints = [];
            
            // Create more points at the start and end of the path for smoother animations
            // This creates a denser point distribution at both ends of the arc
            for (let i = 0; i <= CONFIG.arcPointsCount; i++) { // Use configurable point count
                // Apply non-linear distribution to create more points at the beginning and end
                // Use a modified sine curve to create denser sampling at both ends
                let t;
                if (i === 0) {
                    t = 0;
                } else if (i === CONFIG.arcPointsCount) {
                    t = 1;
                } else {
                    // Use an easing function that creates more points at the start and end
                    // This is a sine-based distribution function that clusters points at both ends
                    const normalizedI = i / CONFIG.arcPointsCount;
                    t = (Math.sin((normalizedI - 0.5) * Math.PI) + 1) / 2;
                }
                
                const point = new THREE.Vector3();
                
                if (i === 0) {
                    // Use adjusted start position for first point to touch globe
                    point.copy(adjustStartPos);
                } else if (i === CONFIG.arcPointsCount) {
                    // Use adjusted end position for last point to touch globe
                    point.copy(adjustEndPos);
                } else {
                    // Use cubic Bezier curve for smoother arcs
                    // Create two control points for better rounding
                    const cp1 = new THREE.Vector3().lerpVectors(adjustStartPos, midPoint, 0.4);
                    const cp2 = new THREE.Vector3().lerpVectors(midPoint, adjustEndPos, 0.6);
                    
                    // Cubic Bezier formula
                    const u = 1 - t;
                    const tt = t * t;
                    const uu = u * u;
                    const uuu = uu * u;
                    const ttt = tt * t;
                    
                    point.x = uuu * adjustStartPos.x + 3 * uu * t * cp1.x + 3 * u * tt * cp2.x + ttt * adjustEndPos.x;
                    point.y = uuu * adjustStartPos.y + 3 * uu * t * cp1.y + 3 * u * tt * cp2.y + ttt * adjustEndPos.y;
                    point.z = uuu * adjustStartPos.z + 3 * uu * t * cp1.z + 3 * u * tt * cp2.z + ttt * adjustEndPos.z;
                }
                
                allPoints.push(point);
            }
            
            // For initial creation, use multiple points to make a smoother initial tube
            // Using more points at the start creates a smoother initial appearance
            const initialPoints = [allPoints[0], allPoints[1], allPoints[2], allPoints[3]];
            const tubePath = new THREE.CatmullRomCurve3(initialPoints);
            tubePath.tension = 0.5; // Set tension for smoother curve
            
            // Create a tube geometry with smoother settings
            const tubeGeometry = new THREE.TubeGeometry(
                tubePath, 
                3, // Use more segments for smoother initial appearance
                CONFIG.arcThickness, 
                CONFIG.arcRadialSegments, 
                false
            ); // Use configurable settings
            
            // Create the tube material with flat color (no lighting/gradient effects)
            const tubeMaterial = new THREE.MeshBasicMaterial({
                color: 0xccddff, // Light blue-white color for arcs
                opacity: 0.9,
                transparent: true
            });
            
            // Create the mesh and add to globe group
            const arc = new THREE.Mesh(tubeGeometry, tubeMaterial);
            globeGroup.add(arc);
            
            return {
                arc: arc,
                tubeMaterial: tubeMaterial,
                allPoints: allPoints,
                progress: 0,
                growDuration: CONFIG.arcGrowDuration + Math.random() * 0.4, // Configurable growth time
                maxLife: CONFIG.arcRetreatDuration + Math.random() * 0.8, // Configurable retreat time
                age: 0,
                destinationPoint: endPos.clone(), // Store the destination point for impact effect
                impactCreated: false // Flag to track if impact effect has been created
            };
        }
        
        // Create explosion effect at arc destinations
        function createImpactEffect(position) {
            // Create a primary circle that will expand outward
            const circleGeometry = new THREE.CircleGeometry(0.05, 16); // Smaller initial size
            const circleMaterial = new THREE.MeshBasicMaterial({
                color: 0x88ccff, // Light blue color for impact
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });
            
            const circle = new THREE.Mesh(circleGeometry, circleMaterial);
            
            // Position at the destination point
            circle.position.copy(position);
            
            // Make circle face outward from globe center
            circle.lookAt(new THREE.Vector3(0, 0, 0));
            
            // Add to globe group
            globeGroup.add(circle);
            
            // Create a secondary outer circle with different color
            const outerCircleGeometry = new THREE.CircleGeometry(0.07, 16); // Smaller initial size
            const outerCircleMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff, // White color for outer circle
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.6
            });
            
            const outerCircle = new THREE.Mesh(outerCircleGeometry, outerCircleMaterial);
            
            // Position at the destination point but slightly behind the inner circle
            outerCircle.position.copy(position);
            
            // Move it slightly toward the globe to avoid z-fighting
            const directionToCenter = new THREE.Vector3(0, 0, 0).sub(position).normalize();
            outerCircle.position.add(directionToCenter.multiplyScalar(0.01));
            
            // Make circle face outward from globe center
            outerCircle.lookAt(new THREE.Vector3(0, 0, 0));
            
            // Add to globe group
            globeGroup.add(outerCircle);
            
            // Return object with properties for animation
            return {
                circle: circle,
                circleMaterial: circleMaterial,
                outerCircle: outerCircle,
                outerCircleMaterial: outerCircleMaterial,
                age: 0,
                maxLife: 0.5 + Math.random() * 0.3,  // Shorter lifespan (0.5-0.8 seconds)
                startTime: performance.now() / 1000  // Current time in seconds
            };
        }
        
        // Store active impact effects
        const impactEffects = [];
        
        // Randomly create arcs
        function addRandomArc() {
            if (landPoints.length < 2) return;
            
            const startIndex = Math.floor(Math.random() * landPoints.length);
            const startPoint = landPoints[startIndex];
            
            // Find suitable endpoints for the arc
            const candidatePoints = [];
            
            // Collect all points within suitable distance range
            // We want a good mix of short, medium and long paths
            for (let i = 0; i < landPoints.length; i++) {
                if (i !== startIndex) {
                    const dist = startPoint.position.distanceTo(landPoints[i].position);
                    // Wider distance range to allow for more varied arcs
                    if (dist > radius * 0.25 && dist < radius * 1.6) {
                        // Calculate a score that prefers points farther away from existing arcs
                        // This prevents clustering of arcs in the same area
                        let proximityScore = 1.0;
                        
                        // Check proximity to existing arc endpoints
                        for (const arc of arcs) {
                            const distToArc = landPoints[i].position.distanceTo(arc.destinationPoint);
                            if (distToArc < radius * 0.3) {
                                // Reduce score for points close to existing arcs
                                proximityScore *= 0.7;
                            }
                        }
                        
                        candidatePoints.push({
                            index: i,
                            distance: dist,
                            score: proximityScore
                        });
                    }
                }
            }
            
            // Select endpoint based on both distance and distribution
            let endPointIndex = -1;
            if (candidatePoints.length > 0) {
                // Sort by a combination of distance and proximity score
                // This creates more evenly distributed arcs around the globe
                candidatePoints.sort((a, b) => {
                    // Use normalized distance (0-1 range) * proximity score
                    const aScore = (a.distance / (radius * 1.6)) * a.score;
                    const bScore = (b.distance / (radius * 1.6)) * b.score;
                    // Randomize slightly to prevent predictable patterns
                    return (aScore + Math.random() * 0.1) - (bScore + Math.random() * 0.1);
                });
                
                // Take top 40% for more varied selection
                const topCount = Math.max(1, Math.floor(candidatePoints.length * 0.4));
                const randomIndex = Math.floor(Math.random() * topCount);
                endPointIndex = candidatePoints[randomIndex].index;
            }
            
            if (endPointIndex !== -1) {
                const endPoint = landPoints[endPointIndex];
                const arc = createArc(startPoint, endPoint);
                arcs.push(arc);
            }
        }
        
        // Raycaster for hover detection
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Variables for mouse rotation
        const mouseRotationSpeed = 0.01; // Keep this separate from auto-rotation
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let globeRotation = { x: 0, y: 0 };
        
        // Handle mouse movement
        function onMouseMove(event) {
            // Update mouse position for raycaster (hover effects)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Handle rotation when dragging
            if (isDragging) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;
                
                globeRotation.y += deltaX * mouseRotationSpeed;
                globeRotation.x += deltaY * mouseRotationSpeed;
                
                // Limit vertical rotation to prevent flipping
                globeRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, globeRotation.x));
                
                // Apply rotation to the entire globe group
                globeGroup.rotation.y = globeRotation.y;
                globeGroup.rotation.x = globeRotation.x;
            }
            
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }
        
        // Handle mouse down - start dragging
        function onMouseDown(event) {
            // Only drag with left mouse button
            if (event.button === 0) {
                isDragging = true;
                previousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
                // Change cursor
                document.body.style.cursor = 'grabbing';
            }
        }
        
        // Handle mouse up - stop dragging
        function onMouseUp() {
            isDragging = false;
            // Reset cursor
            document.body.style.cursor = 'auto';
        }
        
        // Add event listeners
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mouseup', onMouseUp);
        window.addEventListener('mouseleave', onMouseUp);
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        window.addEventListener('resize', onWindowResize);
        
        // Animation loop
        let lastArcTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);
            
            // Convert time to seconds
            const seconds = time / 1000;
            
            // Only auto-rotate if not being dragged - slower rotation for performance
            if (!isDragging) {
                // Use frame skipping for better performance if configured
                if (Math.floor(seconds * 30) % (CONFIG.skipFrames + 1) === 0) {
                    globeRotation.y += CONFIG.rotationSpeed;
                    globeGroup.rotation.y = globeRotation.y;
                }
            }
            
            // No atmosphere updates needed since we're using lighting for glow
            
            // Add subtle pulsing to the back lights for glow effect
            // Only update every few frames for better performance
            if (Math.floor(seconds * 15) % 3 === 0) {
                const elapsedTime = seconds % 10;
                const pulseIntensity = Math.sin(elapsedTime * Math.PI / 5) * 0.05 + 1.0;
                backLight.intensity = 2.0 * pulseIntensity;
                rimLight.intensity = 1.0 * pulseIntensity;
            }
            
            // Add random arcs more aggressively to ensure continuous flow
            if ((seconds - lastArcTime > CONFIG.arcFrequency + (Math.random() * CONFIG.arcTimingVariation)) || 
                // Force arc creation if we're significantly below the maximum
                (arcs.length < CONFIG.maxConcurrentArcs * 0.7 && seconds - lastArcTime > 0.1)) {
                addRandomArc();
                lastArcTime = seconds;
            }
            
            // Only update arcs and impact effects on appropriate frames based on skipFrames
            // Skip frames based on configuration for better performance
            if (Math.floor(seconds * 30) % (CONFIG.skipFrames + 1) === 0) {
                // Update arcs
                for (let i = arcs.length - 1; i >= 0; i--) {
                    const arc = arcs[i];
                    arc.age += 0.02; // Normal increment for smooth animation
                
                // During growth phase - extend the arc
                if (arc.age < arc.growDuration) {
                    // Calculate how far along the growth we are (0 to 1) with easing function
                    let growthProgress = arc.age / arc.growDuration;
                    
                    // Apply easing function for smoother growth (easeInOutQuad)
                    if (growthProgress < 0.5) {
                        growthProgress = 2 * growthProgress * growthProgress;
                    } else {
                        growthProgress = -1 + (4 - 2 * growthProgress) * growthProgress;
                    }
                    
                    // If we've reached 90% of the growth and haven't created an impact effect yet
                    if (growthProgress >= 0.9 && !arc.impactCreated) {
                        // Create impact effect at destination
                        impactEffects.push(createImpactEffect(arc.destinationPoint));
                        arc.impactCreated = true; // Mark that we've created the impact
                    }
                    
                    // Calculate how many points should be visible
                    const pointCount = Math.max(2, Math.floor(growthProgress * arc.allPoints.length));
                    
                    // Get current visible points
                    const currentPoints = arc.allPoints.slice(0, pointCount);
                    
                    try {
                        // Create new tube geometry with current points
                        const tubePath = new THREE.CatmullRomCurve3(currentPoints);
                        
                        // Apply tension for smoother curves
                        tubePath.tension = 0.5;
                        
                        // Calculate dynamic segments for better quality during growth
                        const dynamicSegments = Math.max(
                            3, 
                            Math.min(
                                CONFIG.arcTubeSegments, 
                                Math.ceil(pointCount * 0.7) // Scale segments with curve length
                            )
                        );
                        
                        const newTubeGeometry = new THREE.TubeGeometry(
                            tubePath, 
                            dynamicSegments, // More segments for smoother appearance
                            CONFIG.arcThickness, // Configurable thickness
                            CONFIG.arcRadialSegments, 
                            false
                        );
                        
                        // Remove old mesh from globe group
                        globeGroup.remove(arc.arc);
                        
                        // Dispose old geometry to prevent memory leaks
                        if (arc.arc.geometry) {
                            arc.arc.geometry.dispose();
                        }
                        
                        // Replace with new geometry
                        arc.arc.geometry = newTubeGeometry;
                        
                        // Add back to globe group
                        globeGroup.add(arc.arc);
                    } catch(e) {
                        // If there's an error, just skip this frame
                        console.log("Arc animation error", e);
                    }
                    
                    arc.tubeMaterial.opacity = 0.7; // Full opacity during growth
                }
                // Retreat arcs after growing - line leaves from origin point
                else if (arc.age > arc.growDuration) {
                    // Calculate retreat progress (0 to 1) with improved easing
                    let retreatProgress = Math.min(1, (arc.age - arc.growDuration) / arc.maxLife);
                    
                    // Apply custom easing function for smoother retreat
                    // This creates a slow start, fast middle, and slow end
                    retreatProgress = Math.pow(retreatProgress, 2) * (3 - 2 * retreatProgress);
                    
                    // Apply additional easing at the beginning for an even smoother start
                    if (retreatProgress < 0.2) {
                        retreatProgress = retreatProgress * retreatProgress * 5;
                    }
                    
                    // Calculate how many points should be visible as the line retreats
                    // Use non-linear mapping for smoother retreat
                    const startIndex = Math.floor(retreatProgress * arc.allPoints.length);
                    const pointCount = arc.allPoints.length - startIndex;
                    
                    // Skip if too few points remain
                    if (pointCount < 2) {
                        // Skip rendering when almost gone
                        arc.tubeMaterial.opacity = 0;
                        continue;
                    }
                    
                    // Get current visible points - shifting starting position as line retreats
                    const currentPoints = arc.allPoints.slice(startIndex);
                    
                    try {
                        // Create new tube geometry with retreating points
                        const tubePath = new THREE.CatmullRomCurve3(currentPoints);
                        
                        // Apply tension for smoother curves during retreat
                        tubePath.tension = 0.5;
                        
                        // Use higher segment count for smoother retreating appearance
                        const dynamicSegments = Math.max(
                            3, 
                            Math.min(
                                CONFIG.arcTubeSegments, 
                                Math.ceil(pointCount * 0.8) // Higher scaling for retreat
                            )
                        );
                        
                        const newTubeGeometry = new THREE.TubeGeometry(
                            tubePath, 
                            dynamicSegments,
                            // Gradually thin the arc as it retreats for a more elegant disappearance
                            CONFIG.arcThickness * (1 - (retreatProgress * 0.2)), // Slightly reduce thickness
                            CONFIG.arcRadialSegments,
                            false
                        );
                        
                        // Remove old mesh from globe group
                        globeGroup.remove(arc.arc);
                        
                        // Dispose old geometry to prevent memory leaks
                        if (arc.arc.geometry) {
                            arc.arc.geometry.dispose();
                        }
                        
                        // Replace with new geometry
                        arc.arc.geometry = newTubeGeometry;
                        
                        // Add back to globe group
                        globeGroup.add(arc.arc);
                    } catch(e) {
                        // If there's an error, just skip this frame
                        console.log("Arc retreat animation error", e);
                    }
                }
                
                // Remove old arcs
                if (arc.age >= arc.growDuration + arc.maxLife) {
                    globeGroup.remove(arc.arc);
                    arc.arc.geometry.dispose();
                    arcs.splice(i, 1);
                }
            }
            
            // Update impact effects
            for (let i = impactEffects.length - 1; i >= 0; i--) {
                const effect = impactEffects[i];
                effect.age += 0.02; // Match arc update rate
                
                if (effect.age < effect.maxLife) {
                    // Calculate current size based on age (expand over time)
                    const progress = effect.age / effect.maxLife;
                    
                    // Inner circle - expands over time but stays smaller
                    const innerRadius = progress * radius * CONFIG.impactSize; // Use configurable impact size
                    
                    // Update inner circle geometry
                    globeGroup.remove(effect.circle);
                    if (effect.circle.geometry) {
                        effect.circle.geometry.dispose();
                    }
                    
                    // Create new geometry with updated size
                    const newGeometry = new THREE.CircleGeometry(innerRadius, 16);
                    effect.circle.geometry = newGeometry;
                    
                    // Update inner circle opacity (fade out towards the end)
                    effect.circleMaterial.opacity = Math.max(0, 0.8 * (1 - Math.pow(progress, 1.5)));
                    
                    // Add back to scene
                    globeGroup.add(effect.circle);
                    
                    // Outer circle (expands faster)
                    const outerRadius = innerRadius * 1.3; // 30% larger than inner circle
                    
                    // Update outer circle geometry
                    globeGroup.remove(effect.outerCircle);
                    if (effect.outerCircle.geometry) {
                        effect.outerCircle.geometry.dispose();
                    }
                    
                    // Create new geometry with updated size
                    const newOuterGeometry = new THREE.CircleGeometry(outerRadius, 16);
                    effect.outerCircle.geometry = newOuterGeometry;
                    
                    // Update outer circle opacity (fade out faster)
                    effect.outerCircleMaterial.opacity = Math.max(0, 0.6 * (1 - Math.pow(progress, 2)));
                    
                    // Add back to scene
                    globeGroup.add(effect.outerCircle);
                    
                    // Move slightly behind to avoid z-fighting as they grow
                    const directionToCenter = new THREE.Vector3(0, 0, 0).sub(effect.outerCircle.position).normalize();
                    effect.outerCircle.position.copy(effect.circle.position);
                    effect.outerCircle.position.add(directionToCenter.multiplyScalar(0.01));
                    
                    // Make sure the circles face outward
                    effect.circle.lookAt(new THREE.Vector3(0, 0, 0));
                    effect.outerCircle.lookAt(new THREE.Vector3(0, 0, 0));
                } else {
                    // Smoother transition at the end of effect - fade to zero before removing
                    if (effect.circleMaterial.opacity > 0.05) {
                        // Rapidly fade out remaining opacity
                        effect.circleMaterial.opacity *= 0.7;
                        effect.outerCircleMaterial.opacity *= 0.7;
                        
                        // Skip to next iteration but don't remove the effect yet
                        continue;
                    }
                    
                    // Remove old impact effects - inner circle
                    globeGroup.remove(effect.circle);
                    if (effect.circle.geometry) {
                        effect.circle.geometry.dispose();
                    }
                    effect.circleMaterial.dispose();
                    
                    // Remove outer circle
                    globeGroup.remove(effect.outerCircle);
                    if (effect.outerCircle.geometry) {
                        effect.outerCircle.geometry.dispose();
                    }
                    effect.outerCircleMaterial.dispose();
                    
                    impactEffects.splice(i, 1);
                }
                }
            } // Close the frame skipping condition
            
            // Hover effect on dots - can skip some frames for better performance
            if (Math.floor(seconds * 30) % Math.max(1, Math.floor(CONFIG.skipFrames / 2 + 1)) === 0) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(landDots.children);
            
            // Reset all dots first with smoother transition
            landDots.children.forEach(dot => {
                if (!intersects.find(intersect => intersect.object === dot) && dot.userData.hovering) {
                    // Return dot to original position with smoother transition
                    dot.userData.hovering = false;
                    const origPos = dot.userData.originalPosition;
                    dot.position.lerp(origPos, 0.05); // Slower transition (0.05 instead of 0.1)
                }
            });
            
            // Handle hover
            if (intersects.length > 0) {
                const dot = intersects[0].object;
                dot.userData.hovering = true;
                
                // Move dot away from center with smoother transition
                const direction = dot.position.clone().normalize();
                const targetPosition = dot.userData.originalPosition.clone().add(
                    direction.multiplyScalar(0.3) // Less exaggerated movement (0.3 instead of 0.4)
                );
                dot.position.lerp(targetPosition, 0.05); // Slower transition (0.05 instead of 0.1)
                }
            } // Close the hover effect condition
            
            renderer.render(scene, camera);
        }
        
        // Function to initialize multiple arcs at startup
        function initializeArcs() {
            // Create a initial batch of arcs to start with
            const initialArcCount = Math.floor(CONFIG.maxConcurrentArcs * 0.5); // Start with 50% of max arcs
            console.log(`Creating ${initialArcCount} initial arcs...`);
            
            // Create arcs with varied growth progress
            for (let i = 0; i < initialArcCount; i++) {
                // Create the arc
                addRandomArc();
                
                // Set random initial age so arcs don't all grow/fade simultaneously
                if (arcs.length > 0) {
                    const randomProgress = Math.random();
                    const arc = arcs[arcs.length - 1];
                    
                    // Set up initial age to have arcs in various stages
                    if (randomProgress < 0.7) {
                        // 70% of initial arcs in growth phase
                        arc.age = arc.growDuration * Math.random() * 0.9;
                    } else {
                        // 30% in retreat phase
                        arc.age = arc.growDuration + (Math.random() * arc.maxLife * 0.5);
                    }
                }
            }
        }
        
        // Initialize arcs before starting animation
        initializeArcs();
        
        // Start animation loop
        animate(0);
    </script>
</body>
</html>